

<!DOCTYPE html>
<html lang="zh-Hans" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>RocketMQ进阶三之组件解读 - 笑容+</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  <meta name="keywords" content="技术博客, Java, Python, Node.js, Web 开发">
  <meta name="description" content="RocketMQ NameServer启动过程梳理
�...">
  <meta name="author" content="单线程垃圾清理工">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="https://at.alicdn.com/t/font_1445822_p6ry5n7lrr.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      loading: {
        gif: '/images/theme/loading.gif',
        lottie: ''
      },
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: {
          gif: '/images/theme/loading.gif',
          lottie: ''
        }
      },
      donate: {
        enable: false,
        alipay: 'https://pic.izhaoo.com/alipay.jpg',
        wechat: 'https://pic.izhaoo.com/wechat.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'simple'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: false,
        path: ''
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 7.3.0"></head>

<body class="lock-screen">
  <div class="loading" id="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
    </div>
    <div class="center">RocketMQ进阶三之组件解读</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries/ " class="underline "> 生活</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/theme/post-image.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">RocketMQ进阶三之组件解读</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>June 03, 2024</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>18487</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        
        <h1 id="RocketMQ-NameServer启动过程梳理"><a href="#RocketMQ-NameServer启动过程梳理" class="headerlink" title="RocketMQ NameServer启动过程梳理"></a><strong>RocketMQ NameServer启动过程梳理</strong></h1><hr>
<h2 id="🧩-1-入口类-NamesrvStartup-main"><a href="#🧩-1-入口类-NamesrvStartup-main" class="headerlink" title="🧩 1. 入口类 NamesrvStartup.main()"></a>🧩 1. 入口类 <code>NamesrvStartup.main()</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    start(createNamesrvController(args));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是标准的启动入口，主要做两件事：</p>
<ol>
<li><p>创建 NamesrvController（核心控制器）</p>
</li>
<li><p>启动控制器</p>
</li>
</ol>
<hr>
<h2 id="🔧-2-创建-NamesrvController"><a href="#🔧-2-创建-NamesrvController" class="headerlink" title="🔧 2. 创建 NamesrvController"></a>🔧 2. 创建 NamesrvController</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> NamesrvController <span class="hljs-title function_">createNamesrvController</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">NamesrvConfig</span> <span class="hljs-variable">namesrvConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamesrvConfig</span>();<br>    <span class="hljs-type">NettyServerConfig</span> <span class="hljs-variable">nettyServerConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyServerConfig</span>();<br>    nettyServerConfig.setListenPort(<span class="hljs-number">9876</span>);<br><br>    <span class="hljs-comment">// 解析命令行参数 &amp; 加载配置文件</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">NamesrvController</span> <span class="hljs-variable">controller</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamesrvController</span>(namesrvConfig, nettyServerConfig);<br><br>    <span class="hljs-comment">// 初始化</span><br>    controller.initialize();<br>    <span class="hljs-keyword">return</span> controller;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里完成：</p>
<ul>
<li><p>配置初始化</p>
</li>
<li><p>实例化核心组件 NamesrvController</p>
</li>
<li><p>调用 <code>controller.initialize()</code> 初始化内部子组件</p>
</li>
</ul>
<hr>
<h2 id="⚙️-3-NamesrvController-initialize"><a href="#⚙️-3-NamesrvController-initialize" class="headerlink" title="⚙️ 3. NamesrvController.initialize()"></a>⚙️ 3. <code>NamesrvController.initialize()</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.kvConfigManager.load();<br><br>    <span class="hljs-built_in">this</span>.remotingServer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyRemotingServer</span>(<span class="hljs-built_in">this</span>.nettyServerConfig, <span class="hljs-built_in">this</span>.brokerHousekeepingService);<br><br>    <span class="hljs-built_in">this</span>.remotingExecutor = Executors.newFixedThreadPool(...<br>    <span class="hljs-built_in">this</span>.registerProcessor();<br><br>    <span class="hljs-built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(...);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重点：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>kvConfigManager.load()</code></td>
<td>加载本地配置（KV 存储）</td>
</tr>
<tr>
<td><code>NettyRemotingServer</code></td>
<td>创建 Netty 服务，监听端口（默认 9876）</td>
</tr>
<tr>
<td><code>registerProcessor()</code></td>
<td>注册请求处理器，例如 <code>DefaultRequestProcessor</code></td>
</tr>
<tr>
<td><code>scheduledExecutorService</code></td>
<td>定时清理无效 Broker、打印路由等</td>
</tr>
</tbody></table>
<hr>
<h2 id="🏁-4-NamesrvController-start"><a href="#🏁-4-NamesrvController-start" class="headerlink" title="🏁 4. NamesrvController.start()"></a>🏁 4. <code>NamesrvController.start()</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-built_in">this</span>.remotingServer.start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>启动 Netty 监听服务，对外提供服务。</p>
<hr>
<h2 id="🔄-后台定时任务"><a href="#🔄-后台定时任务" class="headerlink" title="🔄 后台定时任务"></a>🔄 后台定时任务</h2><p>初始化过程中注册了多个定时任务：</p>
<ul>
<li><p>清理不活跃的 Broker（<code>scanNotActiveBroker</code>）</p>
</li>
<li><p>打印当前路由信息</p>
</li>
<li><p>打印 KV 配置</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<br>    () -&gt; NamesrvController.<span class="hljs-built_in">this</span>.routeInfoManager.scanNotActiveBroker(),<br>    <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="🪜-启动流程总结图"><a href="#🪜-启动流程总结图" class="headerlink" title="🪜 启动流程总结图"></a>🪜 启动流程总结图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">namesrv.sh<br>   ↓<br>NamesrvStartup.main()<br>   ↓<br>createNamesrvController()<br>   ↓<br>NamesrvController.initialize()<br>   - 加载配置<br>   - 启动 Netty 服务<br>   - 注册处理器<br>   - 启动定时任务<br>   ↓<br>NamesrvController.start()<br>   ↓<br>NettyRemotingServer.start()<br>   → 监听端口 9876，等待 Broker 注册 / Producer 查询<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="💡-一些细节补充"><a href="#💡-一些细节补充" class="headerlink" title="💡 一些细节补充"></a>💡 一些细节补充</h2><h3 id="1-路由信息的管理"><a href="#1-路由信息的管理" class="headerlink" title="1. 路由信息的管理"></a>1. 路由信息的管理</h3><p>由 <code>RouteInfoManager</code> 负责管理 Broker 的注册信息、Topic 路由等。</p>
<h3 id="2-Broker-注册原理"><a href="#2-Broker-注册原理" class="headerlink" title="2. Broker 注册原理"></a>2. Broker 注册原理</h3><p>Broker 启动时会发送 <code>REGISTER_BROKER</code> 请求，NameServer 收到后通过 <code>DefaultRequestProcessor</code> 处理，注册到 <code>RouteInfoManager</code>。</p>
<hr>
<h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ 总结</h2><p>RocketMQ 的 NameServer 启动过程看似简单，实则细节丰富。主要流程如下：</p>
<ol>
<li><p>解析配置，创建 NamesrvController</p>
</li>
<li><p>初始化核心组件（Netty 服务、定时任务等）</p>
</li>
<li><p>启动监听服务，提供路由中心能力</p>
</li>
</ol>
<h1 id="RocketMQ-Broker启动过程梳理"><a href="#RocketMQ-Broker启动过程梳理" class="headerlink" title="RocketMQ Broker启动过程梳理"></a><strong>RocketMQ Broker启动过程梳理</strong></h1><hr>
<h2 id="🚀-启动流程总览"><a href="#🚀-启动流程总览" class="headerlink" title="🚀 启动流程总览"></a>🚀 启动流程总览</h2><p>从 <code>broker.sh</code> 脚本进入，最终会启动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">org.apache.rocketmq.broker.BrokerStartup<br></code></pre></td></tr></table></figure>

<p>完整启动流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">broker.sh<br>   ↓<br>BrokerStartup.main()<br>   ↓<br>createBrokerController()<br>   ↓<br>BrokerController.initialize()<br>   ↓<br>BrokerController.start()<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="🧩-1-BrokerStartup-main"><a href="#🧩-1-BrokerStartup-main" class="headerlink" title="🧩 1. BrokerStartup.main()"></a>🧩 1. <code>BrokerStartup.main()</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    start(createBrokerController(args));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>两件事：</p>
<ol>
<li><p>创建 BrokerController（核心控制器）</p>
</li>
<li><p>启动它！</p>
</li>
</ol>
<hr>
<h2 id="⚙️-2-createBrokerController-args"><a href="#⚙️-2-createBrokerController-args" class="headerlink" title="⚙️ 2. createBrokerController(args)"></a>⚙️ 2. <code>createBrokerController(args)</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BrokerController <span class="hljs-title function_">createBrokerController</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 解析配置项</span><br>    <span class="hljs-type">BrokerConfig</span> <span class="hljs-variable">brokerConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokerConfig</span>();<br>    <span class="hljs-type">NettyServerConfig</span> <span class="hljs-variable">nettyServerConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyServerConfig</span>();<br>    <span class="hljs-type">NettyClientConfig</span> <span class="hljs-variable">nettyClientConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyClientConfig</span>();<br>    <span class="hljs-type">MessageStoreConfig</span> <span class="hljs-variable">messageStoreConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageStoreConfig</span>();<br><br>    <span class="hljs-comment">// 从配置文件加载属性</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">BrokerController</span> <span class="hljs-variable">controller</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokerController</span>(<br>        brokerConfig,<br>        nettyServerConfig,<br>        nettyClientConfig,<br>        messageStoreConfig,<br>        <span class="hljs-comment">// 还有其他配置...</span><br>    );<br><br>    <span class="hljs-comment">// 初始化</span><br>    controller.initialize();<br>    <span class="hljs-keyword">return</span> controller;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>构造了各种配置对象，组合成 <code>BrokerController</code> 控制器对象，并初始化。</p>
<hr>
<h2 id="🔧-3-BrokerController-initialize"><a href="#🔧-3-BrokerController-initialize" class="headerlink" title="🔧 3. BrokerController.initialize()"></a>🔧 3. <code>BrokerController.initialize()</code></h2><p>这个方法是启动逻辑的核心！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>    <span class="hljs-comment">// 加载 Topic 配置</span><br>    <span class="hljs-built_in">this</span>.topicConfigManager.load();<br><br>    <span class="hljs-comment">// 初始化消息存储组件</span><br>    <span class="hljs-built_in">this</span>.messageStore = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMessageStore</span>(...);<br>    <span class="hljs-built_in">this</span>.messageStore.load();<br><br>    <span class="hljs-comment">// 启动 Netty 服务端（接收 Producer/Consumer 请求）</span><br>    <span class="hljs-built_in">this</span>.remotingServer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyRemotingServer</span>(...);<br>    <span class="hljs-built_in">this</span>.registerProcessor();<br><br>    <span class="hljs-comment">// 启动 Netty 客户端（注册 NameServer 用）</span><br>    <span class="hljs-built_in">this</span>.brokerOuterAPI = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokerOuterAPI</span>(nettyClientConfig);<br><br>    <span class="hljs-comment">// 定时任务：向 NameServer 注册</span><br>    <span class="hljs-built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(...);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主要做的事情：</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>topicConfigManager</code></td>
<td>加载 Topic 和队列配置</td>
</tr>
<tr>
<td><code>DefaultMessageStore</code></td>
<td>初始化存储引擎（CommitLog, ConsumeQueue）</td>
</tr>
<tr>
<td><code>NettyRemotingServer</code></td>
<td>启动服务端，监听客户端请求</td>
</tr>
<tr>
<td><code>BrokerOuterAPI</code></td>
<td>Netty 客户端，用于与 NameServer 通信</td>
</tr>
<tr>
<td>定时注册任务</td>
<td>定时向 NameServer 发送 <code>REGISTER_BROKER</code> 请求</td>
</tr>
</tbody></table>
<hr>
<h2 id="🏁-4-BrokerController-start"><a href="#🏁-4-BrokerController-start" class="headerlink" title="🏁 4. BrokerController.start()"></a>🏁 4. <code>BrokerController.start()</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.messageStore != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.messageStore.start();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.remotingServer != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.remotingServer.start();<br>    &#125;<br>    <span class="hljs-built_in">this</span>.startScheduleService();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重点：</p>
<ul>
<li><p>启动消息存储引擎（调度刷盘、索引重建等）</p>
</li>
<li><p>启动 Netty 服务</p>
</li>
<li><p>启动定时任务（如 Broker 状态上报、注册任务）</p>
</li>
</ul>
<hr>
<h2 id="🔁-注册到-NameServer"><a href="#🔁-注册到-NameServer" class="headerlink" title="🔁 注册到 NameServer"></a>🔁 注册到 NameServer</h2><p>注册动作发生在 <code>BrokerController.initialize()</code> 里定时任务中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<br>    () -&gt; <span class="hljs-built_in">this</span>.registerBrokerAll(<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>),<br>    <span class="hljs-number">1000</span>, <span class="hljs-number">30</span> * <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS<br>);<br></code></pre></td></tr></table></figure>

<p>也就是说，<strong>Broker 启动后会每隔 30 秒向所有 NameServer 注册一次</strong>。</p>
<h3 id="注册做了什么？"><a href="#注册做了什么？" class="headerlink" title="注册做了什么？"></a>注册做了什么？</h3><p>发送 <code>REGISTER_BROKER</code> 请求，包括：</p>
<ul>
<li><p>Broker 名称、ID、IP、端口</p>
</li>
<li><p>支持的 Topic 信息</p>
</li>
<li><p>是否是 Master &#x2F; Slave</p>
</li>
<li><p>权重、写权限等</p>
</li>
</ul>
<hr>
<h2 id="💾-消息存储组件-DefaultMessageStore"><a href="#💾-消息存储组件-DefaultMessageStore" class="headerlink" title="💾 消息存储组件 DefaultMessageStore"></a>💾 消息存储组件 DefaultMessageStore</h2><p>初始化存储是 Broker 启动的关键步骤，涉及：</p>
<ul>
<li><p><strong>CommitLog</strong>：写入消息的顺序日志文件</p>
</li>
<li><p><strong>ConsumeQueue</strong>：消息消费队列索引</p>
</li>
<li><p><strong>IndexFile</strong>：关键词索引</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.messageStore = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMessageStore</span>(...);<br><span class="hljs-built_in">this</span>.messageStore.load();<br></code></pre></td></tr></table></figure>

<p>这一步会尝试从磁盘恢复之前的消息存储结构。</p>
<hr>
<h2 id="🧠-启动流程图总结"><a href="#🧠-启动流程图总结" class="headerlink" title="🧠 启动流程图总结"></a>🧠 启动流程图总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">broker.sh<br>   ↓<br>BrokerStartup.main()<br>   ↓<br>createBrokerController()<br>   ↓<br>BrokerController.initialize()<br>   - 加载 Topic 配置<br>   - 初始化消息存储引擎<br>   - 启动 Netty 服务<br>   - 创建 NameServer 客户端<br>   - 启动注册任务<br>   ↓<br>BrokerController.start()<br>   - 启动消息存储调度<br>   - 启动服务端监听<br>   - 启动后台任务<br></code></pre></td></tr></table></figure>
<h1 id="RocketMQ-Netty服务注册框架"><a href="#RocketMQ-Netty服务注册框架" class="headerlink" title="RocketMQ Netty服务注册框架"></a><strong>RocketMQ Netty服务注册框架</strong></h1><hr>
<h2 id="🚀-1-RocketMQ-的服务注册框架组成"><a href="#🚀-1-RocketMQ-的服务注册框架组成" class="headerlink" title="🚀 1. RocketMQ 的服务注册框架组成"></a>🚀 1. RocketMQ 的服务注册框架组成</h2><p>RocketMQ 不是依赖第三方服务注册中心，而是自己构建了一个轻量级的注册中心：</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>NameServer</strong></td>
<td>类似轻量级 ZooKeeper，负责路由注册和查询</td>
</tr>
<tr>
<td><strong>Broker</strong></td>
<td>启动后向 NameServer 注册路由信息（通过 Netty）</td>
</tr>
<tr>
<td><strong>Client</strong></td>
<td>Producer 和 Consumer，从 NameServer 查询路由</td>
</tr>
<tr>
<td><strong>Netty</strong></td>
<td>所有角色之间的通信层，负责传输、编解码、事件管理</td>
</tr>
</tbody></table>
<hr>
<h2 id="🧩-2-NameServer-的注册机制（自研）"><a href="#🧩-2-NameServer-的注册机制（自研）" class="headerlink" title="🧩 2. NameServer 的注册机制（自研）"></a>🧩 2. NameServer 的注册机制（自研）</h2><p>NameServer 本质上是一个 <strong>无状态的路由服务中心</strong>：</p>
<ul>
<li><p>使用 Netty 提供的 <strong>ServerBootstrap</strong> 监听端口（默认 <code>9876</code>）</p>
</li>
<li><p>接收 Broker 注册请求（<code>REGISTER_BROKER</code>）</p>
</li>
<li><p>存储路由信息在内存中的 <code>RouteInfoManager</code> 里</p>
</li>
</ul>
<p>👉 没有依赖 ZooKeeper，<strong>不需要集群一致性协议</strong>（如 Raft 或 Paxos）</p>
<hr>
<h2 id="🧠-3-Broker-注册-NameServer-流程（基于-Netty）"><a href="#🧠-3-Broker-注册-NameServer-流程（基于-Netty）" class="headerlink" title="🧠 3. Broker 注册 NameServer 流程（基于 Netty）"></a>🧠 3. Broker 注册 NameServer 流程（基于 Netty）</h2><h3 id="Broker-启动时会定时注册："><a href="#Broker-启动时会定时注册：" class="headerlink" title="Broker 启动时会定时注册："></a>Broker 启动时会定时注册：</h3><p>在 <code>BrokerController</code> 中注册任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<br>    () -&gt; <span class="hljs-built_in">this</span>.registerBrokerAll(<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>),<br>    <span class="hljs-number">1000</span>, <span class="hljs-number">30</span> * <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS<br>);<br></code></pre></td></tr></table></figure>

<h3 id="注册方法核心逻辑："><a href="#注册方法核心逻辑：" class="headerlink" title="注册方法核心逻辑："></a>注册方法核心逻辑：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RegisterBrokerResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.brokerOuterAPI.registerBrokerAll(<br>    clusterName,<br>    brokerAddr,<br>    brokerName,<br>    brokerId,<br>    haServerAddr,<br>    topicConfigWrapper,<br>    filterServerList,<br>    oneway,<br>    enableActingMaster,<br>    compressedRegister,<br>    timeoutMills<br>);<br></code></pre></td></tr></table></figure>

<p>这一调用通过 Netty 客户端发送请求。</p>
<hr>
<h2 id="🔧-4-Netty-在-RocketMQ-中的使用方式"><a href="#🔧-4-Netty-在-RocketMQ-中的使用方式" class="headerlink" title="🔧 4. Netty 在 RocketMQ 中的使用方式"></a>🔧 4. Netty 在 RocketMQ 中的使用方式</h2><table>
<thead>
<tr>
<th>角色</th>
<th>Netty 组件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>NameServer</td>
<td><code>NettyRemotingServer</code></td>
<td>接收 Broker 注册请求</td>
</tr>
<tr>
<td>Broker</td>
<td><code>NettyRemotingServer</code> + <code>NettyRemotingClient</code></td>
<td>对内接 Producer&#x2F;Consumer，请求 NameServer</td>
</tr>
<tr>
<td>Client</td>
<td><code>NettyRemotingClient</code></td>
<td>请求 NameServer 获取路由</td>
</tr>
</tbody></table>
<p><strong>NettyRemotingServer</strong> 和 <strong>NettyRemotingClient</strong> 是 RocketMQ 自定义的 Netty 通信封装类。</p>
<p>它们基于 Netty 4.x，封装了：</p>
<ul>
<li><p><code>RemotingCommand</code>：RocketMQ 自定义协议</p>
</li>
<li><p>编解码（Header + Body）</p>
</li>
<li><p>请求处理器机制（类似 Dubbo 的 <code>ChannelHandler</code>）</p>
</li>
</ul>
<hr>
<h2 id="✉️-5-注册请求协议（REGISTER-BROKER）"><a href="#✉️-5-注册请求协议（REGISTER-BROKER）" class="headerlink" title="✉️ 5. 注册请求协议（REGISTER_BROKER）"></a>✉️ 5. 注册请求协议（REGISTER_BROKER）</h2><p>RocketMQ 使用自定义协议 <code>RemotingCommand</code>，并定义了注册请求类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">RequestCode.REGISTER_BROKER<br></code></pre></td></tr></table></figure>

<p>处理流程：</p>
<ul>
<li><p>Netty 服务端（NameServer）接收到 REGISTER_BROKER 请求</p>
</li>
<li><p>调用处理器 <code>DefaultRequestProcessor</code></p>
</li>
<li><p>调用 <code>RouteInfoManager.registerBroker(...)</code> 注册 Broker 信息</p>
</li>
<li><p>更新内存中的 topic、broker、队列信息</p>
</li>
</ul>
<hr>
<h2 id="🗂️-6-NameServer-内存结构（注册结果的落地）"><a href="#🗂️-6-NameServer-内存结构（注册结果的落地）" class="headerlink" title="🗂️ 6. NameServer 内存结构（注册结果的落地）"></a>🗂️ 6. NameServer 内存结构（注册结果的落地）</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">RouteInfoManager &#123;<br>  HashMap&lt;String /* topic */, List&lt;QueueData&gt;&gt;<br>  HashMap&lt;String /* brokerName */, BrokerData&gt;<br>  HashMap&lt;String /* clusterName */, Set&lt;brokerName&gt;&gt;<br>  HashMap&lt;String /* brokerAddr */, BrokerLiveInfo&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这些信息存在 NameServer 内存中，每次重启即丢失，但由于 <strong>Broker 定时注册</strong>，可以快速恢复。</p>
<hr>
<h2 id="🎯-小结：RocketMQ-自研的-Netty-服务注册框架"><a href="#🎯-小结：RocketMQ-自研的-Netty-服务注册框架" class="headerlink" title="🎯 小结：RocketMQ 自研的 Netty 服务注册框架"></a>🎯 小结：RocketMQ 自研的 Netty 服务注册框架</h2><table>
<thead>
<tr>
<th>特性</th>
<th>RocketMQ 的做法</th>
</tr>
</thead>
<tbody><tr>
<td>服务注册中心</td>
<td>自研 NameServer</td>
</tr>
<tr>
<td>通信方式</td>
<td>基于 Netty 自定义协议</td>
</tr>
<tr>
<td>注册模式</td>
<td>Broker 主动定时注册</td>
</tr>
<tr>
<td>路由发现</td>
<td>Client 主动拉取路由</td>
</tr>
<tr>
<td>数据一致性</td>
<td>无状态，最终一致性（依赖定时注册）</td>
</tr>
<tr>
<td>易扩展性</td>
<td>高，可动态增减 Broker&#x2F;Topic</td>
</tr>
</tbody></table>
<h1 id="RocketMQ-Broker心跳注册管理"><a href="#RocketMQ-Broker心跳注册管理" class="headerlink" title="RocketMQ Broker心跳注册管理"></a><strong>RocketMQ Broker心跳注册管理</strong></h1><hr>
<h2 id="🎯-目标：Broker-和-NameServer-如何保持“在线感知”"><a href="#🎯-目标：Broker-和-NameServer-如何保持“在线感知”" class="headerlink" title="🎯 目标：Broker 和 NameServer 如何保持“在线感知”"></a>🎯 目标：Broker 和 NameServer 如何保持“在线感知”</h2><p>RocketMQ 使用两种方式来维护 Broker 状态：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>作用</th>
<th>主体</th>
</tr>
</thead>
<tbody><tr>
<td>✅ <strong>Broker 定时注册</strong></td>
<td>主动上报自己和 topic 路由信息</td>
<td>Broker</td>
</tr>
<tr>
<td>✅ <strong>NameServer 定时清理</strong></td>
<td>检查失联 Broker，清除路由</td>
<td>NameServer</td>
</tr>
</tbody></table>
<p>这是一种 <strong>弱心跳 + 注册保活</strong> 机制。</p>
<hr>
<h2 id="🧩-一、Broker-定时注册机制（心跳式注册）"><a href="#🧩-一、Broker-定时注册机制（心跳式注册）" class="headerlink" title="🧩 一、Broker 定时注册机制（心跳式注册）"></a>🧩 一、Broker 定时注册机制（心跳式注册）</h2><h3 id="注册任务在-Broker-初始化时设置："><a href="#注册任务在-Broker-初始化时设置：" class="headerlink" title="注册任务在 Broker 初始化时设置："></a>注册任务在 Broker 初始化时设置：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<br>    () -&gt; <span class="hljs-built_in">this</span>.registerBrokerAll(<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>),<br>    <span class="hljs-number">1000</span>, <span class="hljs-number">30</span> * <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS<br>);<br></code></pre></td></tr></table></figure>

<h3 id="每-30-秒-向所有-NameServer-发送-REGISTER-BROKER-请求"><a href="#每-30-秒-向所有-NameServer-发送-REGISTER-BROKER-请求" class="headerlink" title="每 30 秒 向所有 NameServer 发送 REGISTER_BROKER 请求"></a>每 30 秒 向所有 NameServer 发送 <code>REGISTER_BROKER</code> 请求</h3><p>核心类：<code>BrokerOuterAPI#registerBrokerAll(...)</code></p>
<p>注册信息包括：</p>
<ul>
<li><p>Broker name &#x2F; ID &#x2F; IP</p>
</li>
<li><p>Broker 地址和 HA 地址</p>
</li>
<li><p>Topic 配置（topic + queue 数量）</p>
</li>
<li><p>是否是主节点、写权限等</p>
</li>
</ul>
<hr>
<h2 id="🧠-二、NameServer-处理注册的流程"><a href="#🧠-二、NameServer-处理注册的流程" class="headerlink" title="🧠 二、NameServer 处理注册的流程"></a>🧠 二、NameServer 处理注册的流程</h2><p>NameServer 通过 <code>DefaultRequestProcessor</code> 处理注册请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> REGISTER_BROKER:<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.registerBroker(ctx, request);<br></code></pre></td></tr></table></figure>

<p>在 <code>RouteInfoManager#registerBroker(...)</code> 中：</p>
<ol>
<li><p>将 Broker 信息存入内存</p>
</li>
<li><p>更新 <code>topicQueueTable</code></p>
</li>
<li><p>创建&#x2F;刷新 <code>BrokerLiveInfo</code>（相当于心跳时间戳）</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BrokerLiveInfo</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.brokerLiveTable.put(<br>    brokerAddr,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokerLiveInfo</span>(<br>        System.currentTimeMillis(), <span class="hljs-comment">// 上次注册时间</span><br>        dataVersion,<br>        channel,<br>        haServerAddr<br>    )<br>);<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="🔁-三、心跳超时检查（NameServer-清理死掉的-Broker）"><a href="#🔁-三、心跳超时检查（NameServer-清理死掉的-Broker）" class="headerlink" title="🔁 三、心跳超时检查（NameServer 清理死掉的 Broker）"></a>🔁 三、心跳超时检查（NameServer 清理死掉的 Broker）</h2><p>NameServer 也有自己的定时任务（在 <code>NamesrvController#initialize()</code> 中）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<br>    () -&gt; <span class="hljs-built_in">this</span>.routeInfoManager.scanNotActiveBroker(),<br>    <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS<br>);<br></code></pre></td></tr></table></figure>

<p>每 10 秒扫描一遍 Broker：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (System.currentTimeMillis() - brokerLiveInfo.getLastUpdateTimestamp() &gt; BROKER_CHANNEL_EXPIRED_TIME) &#123;<br>    <span class="hljs-comment">// 默认是 2 分钟</span><br>    <span class="hljs-built_in">this</span>.onChannelDestroy(brokerAddr, channel);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="默认过期时间："><a href="#默认过期时间：" class="headerlink" title="默认过期时间："></a>默认过期时间：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">BROKER_CHANNEL_EXPIRED_TIME</span> <span class="hljs-operator">=</span> <span class="hljs-number">120</span> * <span class="hljs-number">1000L</span>; <span class="hljs-comment">// 2 分钟</span><br></code></pre></td></tr></table></figure>

<p>如果 Broker 超过 2 分钟未注册，就认为掉线并清理路由数据。</p>
<hr>
<h2 id="🗂️-四、核心内存结构（RouteInfoManager）"><a href="#🗂️-四、核心内存结构（RouteInfoManager）" class="headerlink" title="🗂️ 四、核心内存结构（RouteInfoManager）"></a>🗂️ 四、核心内存结构（RouteInfoManager）</h2><p>NameServer 保存 Broker 注册信息的数据结构是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. topic → 队列数据</span><br>HashMap&lt;String <span class="hljs-comment">/* topic */</span>, List&lt;QueueData&gt;&gt; topicQueueTable;<br><br><span class="hljs-comment">// 2. brokerName → BrokerData（包括 master/slave 地址）</span><br>HashMap&lt;String <span class="hljs-comment">/* brokerName */</span>, BrokerData&gt; brokerAddrTable;<br><br><span class="hljs-comment">// 3. clusterName → brokerName 列表</span><br>HashMap&lt;String <span class="hljs-comment">/* clusterName */</span>, Set&lt;String&gt;&gt; clusterAddrTable;<br><br><span class="hljs-comment">// 4. brokerAddr → BrokerLiveInfo（包括最后心跳时间）</span><br>HashMap&lt;String <span class="hljs-comment">/* brokerAddr */</span>, BrokerLiveInfo&gt; brokerLiveTable;<br></code></pre></td></tr></table></figure>

<p>当超时清理时，所有这些结构都会更新。</p>
<hr>
<h2 id="🧪-五、客户端路由查询与容灾"><a href="#🧪-五、客户端路由查询与容灾" class="headerlink" title="🧪 五、客户端路由查询与容灾"></a>🧪 五、客户端路由查询与容灾</h2><ul>
<li><p><strong>Producer&#x2F;Consumer 会定时从 NameServer 拉取最新路由信息</strong></p>
</li>
<li><p>如果 Broker 掉线，NameServer 在两分钟后会清除它</p>
</li>
<li><p>下次客户端拉路由时将不再包含该 Broker，自动实现容灾转移</p>
</li>
</ul>
<hr>
<h2 id="✅-总结一句话："><a href="#✅-总结一句话：" class="headerlink" title="✅ 总结一句话："></a>✅ 总结一句话：</h2><blockquote>
<p>RocketMQ 的 Broker 通过每 30 秒一次的定时注册，维持和 NameServer 的“心跳”；NameServer 每 10 秒扫描一次 Broker 活跃状态，超过 2 分钟未注册即判为掉线，自动清除其路由信息。</p>
</blockquote>
<p>这种机制简单、无中心化依赖、极易扩展，非常适合高性能场景。</p>
<hr>
<h2 id="📌-补充：主从-Broker-的注册差异"><a href="#📌-补充：主从-Broker-的注册差异" class="headerlink" title="📌 补充：主从 Broker 的注册差异"></a>📌 补充：主从 Broker 的注册差异</h2><ul>
<li><p>主节点（Master）和从节点（Slave）都会注册到 NameServer</p>
</li>
<li><p>主节点的路由通常用于写操作</p>
</li>
<li><p>如果主节点挂了，只有在 <strong>手动选主</strong> 或使用 <strong>ActingMaster 模式</strong> 才能恢复写能力（RocketMQ 5.x）</p>
</li>
</ul>
<h1 id="RocketMQ-Producer发送消息过程解读"><a href="#RocketMQ-Producer发送消息过程解读" class="headerlink" title="RocketMQ Producer发送消息过程解读"></a><strong>RocketMQ Producer发送消息过程解读</strong></h1><hr>
<h2 id="1-Producer-发送消息的入口"><a href="#1-Producer-发送消息的入口" class="headerlink" title="1. Producer 发送消息的入口"></a>1. Producer 发送消息的入口</h2><p>用户业务代码通常调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> producer.send(Message msg);<br></code></pre></td></tr></table></figure>

<p>这个方法底层会调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sendDefaultImpl(msg, communicationMode, sendCallback, timeout);<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="2-路由获取（向-NameServer-拉取-Topic-路由）"><a href="#2-路由获取（向-NameServer-拉取-Topic-路由）" class="headerlink" title="2. 路由获取（向 NameServer 拉取 Topic 路由）"></a>2. 路由获取（向 NameServer 拉取 Topic 路由）</h2><p>发送前，Producer 需要知道：</p>
<ul>
<li><p>Topic 对应的 Broker 列表</p>
</li>
<li><p>Broker 上的写队列数量</p>
</li>
</ul>
<p>RocketMQ 使用 <strong><code>MQClientInstance</code></strong> 管理客户端实例和路由信息缓存。</p>
<ul>
<li><p><code>MQClientInstance.getTopicRouteInfoFromNameServer(...)</code> 触发向 NameServer 拉取最新路由</p>
</li>
<li><p>路由信息缓存在 <code>TopicPublishInfo</code> 对象中</p>
</li>
</ul>
<hr>
<h2 id="3-选择消息队列（负载均衡）"><a href="#3-选择消息队列（负载均衡）" class="headerlink" title="3. 选择消息队列（负载均衡）"></a>3. 选择消息队列（负载均衡）</h2><p>Producer 调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MessageQueue</span> <span class="hljs-variable">mq</span> <span class="hljs-operator">=</span> topicPublishInfo.selectMessageQueue();<br></code></pre></td></tr></table></figure>

<p>选择算法：</p>
<ul>
<li><p>轮询（默认）</p>
</li>
<li><p>按写权重或 Broker 策略</p>
</li>
<li><p>可自定义</p>
</li>
</ul>
<p><code>MessageQueue</code> 包含：</p>
<ul>
<li><p>BrokerName</p>
</li>
<li><p>队列ID（队列序号）</p>
</li>
<li><p>队列权限（写&#x2F;读）</p>
</li>
</ul>
<hr>
<h2 id="4-发送消息（调用网络通信）"><a href="#4-发送消息（调用网络通信）" class="headerlink" title="4. 发送消息（调用网络通信）"></a>4. 发送消息（调用网络通信）</h2><h3 id="4-1-发送接口调用"><a href="#4-1-发送接口调用" class="headerlink" title="4.1 发送接口调用"></a>4.1 发送接口调用</h3><p>Producer 调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sendKernelImpl(msg, mq, communicationMode, sendCallback, timeout);<br></code></pre></td></tr></table></figure>

<p>根据通信模式选择：</p>
<ul>
<li><p>同步（SYNC）</p>
</li>
<li><p>异步（ASYNC）</p>
</li>
<li><p>单向（ONEWAY）</p>
</li>
</ul>
<hr>
<h3 id="4-2-发送请求构造（RemotingCommand）"><a href="#4-2-发送请求构造（RemotingCommand）" class="headerlink" title="4.2 发送请求构造（RemotingCommand）"></a>4.2 发送请求构造（RemotingCommand）</h3><p>内部封装成 RocketMQ 自定义的请求协议 <code>RemotingCommand</code>，包括：</p>
<ul>
<li><p>请求码（<code>SEND_MESSAGE</code>）</p>
</li>
<li><p>消息体（经序列化）</p>
</li>
<li><p>主题、队列ID、标记等元数据</p>
</li>
</ul>
<hr>
<h3 id="4-3-通过-Netty-发送消息"><a href="#4-3-通过-Netty-发送消息" class="headerlink" title="4.3 通过 Netty 发送消息"></a>4.3 通过 Netty 发送消息</h3><p>Producer 底层使用 <code>NettyRemotingClient</code> 连接 Broker：</p>
<ul>
<li><p>创建 TCP 连接（长连接复用）</p>
</li>
<li><p>发送消息请求</p>
</li>
<li><p>等待 Broker 响应（同步或异步回调）</p>
</li>
</ul>
<hr>
<h2 id="5-Broker-接收并处理消息"><a href="#5-Broker-接收并处理消息" class="headerlink" title="5. Broker 接收并处理消息"></a>5. Broker 接收并处理消息</h2><p>Broker 收到发送请求后：</p>
<ul>
<li><p>进行权限校验（Topic 是否允许写入）</p>
</li>
<li><p>持久化消息到 CommitLog</p>
</li>
<li><p>更新消费队列（ConsumerQueue）</p>
</li>
<li><p>返回消息存储结果（包括 MsgId、存储偏移量）</p>
</li>
</ul>
<hr>
<h2 id="6-Producer-接收响应"><a href="#6-Producer-接收响应" class="headerlink" title="6. Producer 接收响应"></a>6. Producer 接收响应</h2><ul>
<li><p>同步模式下等待响应，得到 <code>SendResult</code> 对象</p>
</li>
<li><p>异步模式下通过回调函数处理结果</p>
</li>
<li><p>单向模式不等待响应</p>
</li>
</ul>
<hr>
<h2 id="7-失败重试和事务消息"><a href="#7-失败重试和事务消息" class="headerlink" title="7. 失败重试和事务消息"></a>7. 失败重试和事务消息</h2><ul>
<li><p>如果发送失败，Producer 支持自动重试</p>
</li>
<li><p>事务消息则进入两阶段提交流程（这里不细说）</p>
</li>
</ul>
<hr>
<h2 id="📝-流程总结图"><a href="#📝-流程总结图" class="headerlink" title="📝 流程总结图"></a>📝 流程总结图</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">[业务调用 producer.send()]<br>           ↓<br>  获取 Topic 路由信息（NameServer）<br>           ↓<br>   选择消息队列（MessageQueue）<br>           ↓<br>构造发送请求（RemotingCommand）<br>           ↓<br>      Netty 发送消息请求<br>           ↓<br>        Broker 处理消息<br>           ↓<br>     返回发送结果响应<br>           ↓<br>      Producer 处理响应<br>           ↓<br>       返回给业务层 SendResult<br></code></pre></td></tr></table></figure>
<h1 id="RocketMQ-Consumer拉取消息过程解读"><a href="#RocketMQ-Consumer拉取消息过程解读" class="headerlink" title="RocketMQ Consumer拉取消息过程解读"></a><strong>RocketMQ Consumer拉取消息过程解读</strong></h1><hr>
<h2 id="1-Consumer-启动订阅流程"><a href="#1-Consumer-启动订阅流程" class="headerlink" title="1. Consumer 启动订阅流程"></a>1. Consumer 启动订阅流程</h2><p>用户调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">consumer.subscribe(topic, subExpression);<br></code></pre></td></tr></table></figure>

<ul>
<li><p>订阅主题和过滤表达式</p>
</li>
<li><p>Consumer 向 <code>MQClientInstance</code> 注册订阅关系</p>
</li>
<li><p>客户端开始维护对应 Topic 的消息队列（MessageQueue）列表</p>
</li>
</ul>
<hr>
<h2 id="2-拉取消息触发点"><a href="#2-拉取消息触发点" class="headerlink" title="2. 拉取消息触发点"></a>2. 拉取消息触发点</h2><p>RocketMQ 主要有两种消费模式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>消费触发方式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Push</strong></td>
<td>Consumer 长轮询 Broker，收到消息后回调监听器</td>
</tr>
<tr>
<td><strong>Pull</strong></td>
<td>业务主动调用 <code>pull</code> 接口拉消息</td>
</tr>
</tbody></table>
<p><strong>默认是 Push 模式</strong>，消费者客户端内部实现了定时或异步拉取消息。</p>
<hr>
<h2 id="3-获取-Topic-路由信息"><a href="#3-获取-Topic-路由信息" class="headerlink" title="3. 获取 Topic 路由信息"></a>3. 获取 Topic 路由信息</h2><p>类似 Producer，Consumer 也需要从 NameServer 获取 Topic 路由信息，确定可用 Broker 列表和队列分布。</p>
<ul>
<li><p>缓存在 <code>TopicSubscribeInfo</code></p>
</li>
<li><p>包含 MessageQueue 列表和读写权限信息</p>
</li>
</ul>
<hr>
<h2 id="4-拉取消息请求构造"><a href="#4-拉取消息请求构造" class="headerlink" title="4. 拉取消息请求构造"></a>4. 拉取消息请求构造</h2><p>客户端根据订阅的队列和消费进度（offset）构造拉取请求，包含：</p>
<ul>
<li><p>Topic 名称</p>
</li>
<li><p>队列 ID（MessageQueue）</p>
</li>
<li><p>消费进度（offset）</p>
</li>
<li><p>消息数量（batch size）</p>
</li>
<li><p>过滤表达式（可选）</p>
</li>
</ul>
<hr>
<h2 id="5-发送拉取请求（Netty-通信）"><a href="#5-发送拉取请求（Netty-通信）" class="headerlink" title="5. 发送拉取请求（Netty 通信）"></a>5. 发送拉取请求（Netty 通信）</h2><p>Consumer 底层使用 <code>NettyRemotingClient</code> 连接 Broker，发送：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">RequestCode.PULL_MESSAGE<br></code></pre></td></tr></table></figure>

<p>请求包含拉取参数。</p>
<hr>
<h2 id="6-Broker-处理拉取请求"><a href="#6-Broker-处理拉取请求" class="headerlink" title="6. Broker 处理拉取请求"></a>6. Broker 处理拉取请求</h2><p>Broker 接收到拉取请求：</p>
<ul>
<li><p>根据 Topic + Queue + Offset 查询消息存储（CommitLog）</p>
</li>
<li><p>过滤符合条件的消息（如果有过滤表达式）</p>
</li>
<li><p>将消息打包返回给 Consumer</p>
</li>
</ul>
<hr>
<h2 id="7-Consumer-接收消息"><a href="#7-Consumer-接收消息" class="headerlink" title="7. Consumer 接收消息"></a>7. Consumer 接收消息</h2><ul>
<li><p>Consumer 收到消息数据包</p>
</li>
<li><p>解析成消息对象集合（MessageExtList）</p>
</li>
<li><p>调用用户定义的消息监听器（MessageListener）处理消息</p>
</li>
</ul>
<hr>
<h2 id="8-消费进度提交（offset-管理）"><a href="#8-消费进度提交（offset-管理）" class="headerlink" title="8. 消费进度提交（offset 管理）"></a>8. 消费进度提交（offset 管理）</h2><p>消费成功后，Consumer 会更新消费进度：</p>
<ul>
<li><p><strong>自动提交</strong>（默认）</p>
</li>
<li><p>或者业务代码主动调用 <code>commit()</code> 更新</p>
</li>
</ul>
<p>消费进度可存储在：</p>
<ul>
<li><p>Broker（基于消费组维度）</p>
</li>
<li><p>本地文件或其他持久化介质（高级选项）</p>
</li>
</ul>
<hr>
<h2 id="9-消息重试和失败处理"><a href="#9-消息重试和失败处理" class="headerlink" title="9. 消息重试和失败处理"></a>9. 消息重试和失败处理</h2><ul>
<li><p>如果消费失败，消息会被重新投递（重试机制）</p>
</li>
<li><p>达到最大重试次数后，消息可能被转入死信队列（DLQ）</p>
</li>
</ul>
<hr>
<h2 id="📝-拉取消息流程简化图"><a href="#📝-拉取消息流程简化图" class="headerlink" title="📝 拉取消息流程简化图"></a>📝 拉取消息流程简化图</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">Consumer启动订阅<br>       ↓<br>获取Topic路由信息<br>       ↓<br>根据offset构造拉取请求<br>       ↓<br>  Netty发送PULL_MESSAGE请求<br>       ↓<br> Broker查询消息并返回<br>       ↓<br> Consumer接收并处理消息<br>       ↓<br>更新消费进度offset<br>       ↓<br>消息消费成功 / 重试或DLQ<br></code></pre></td></tr></table></figure>
<h1 id="RocketMQ-消息持久化机制介绍"><a href="#RocketMQ-消息持久化机制介绍" class="headerlink" title="RocketMQ 消息持久化机制介绍"></a><strong>RocketMQ 消息持久化机制介绍</strong></h1><hr>
<h2 id="1-RocketMQ-持久化概述"><a href="#1-RocketMQ-持久化概述" class="headerlink" title="1. RocketMQ 持久化概述"></a>1. RocketMQ 持久化概述</h2><p>RocketMQ 的消息持久化设计注重 <strong>高性能与数据安全</strong>，其核心是基于 <strong>顺序写入</strong> 和 <strong>文件映射内存</strong>，配合多种机制确保消息不会丢失。</p>
<hr>
<h2 id="2-核心存储组件"><a href="#2-核心存储组件" class="headerlink" title="2. 核心存储组件"></a>2. 核心存储组件</h2><table>
<thead>
<tr>
<th>组件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CommitLog</strong></td>
<td>消息存储主文件，顺序追加写入消息数据</td>
</tr>
<tr>
<td><strong>ConsumeQueue</strong></td>
<td>消息消费索引，指向 CommitLog 中消息位置</td>
</tr>
<tr>
<td><strong>IndexFile</strong></td>
<td>消息索引文件，支持按 key 查询消息</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-CommitLog-详解"><a href="#3-CommitLog-详解" class="headerlink" title="3. CommitLog 详解"></a>3. CommitLog 详解</h2><ul>
<li><p><strong>顺序追加写入</strong>：消息数据写入到一个大文件，按顺序写，避免随机磁盘 I&#x2F;O</p>
</li>
<li><p>默认文件大小：1GB 一个文件（文件名以偏移量命名）</p>
</li>
<li><p><strong>消息结构</strong>：消息头 + 消息体 + 校验码 + 其他元信息</p>
</li>
<li><p><strong>内存映射文件（MappedFile）</strong>：使用 <code>MappedByteBuffer</code>，将文件映射到内存，提高读写效率</p>
</li>
</ul>
<hr>
<h2 id="4-消息写入流程"><a href="#4-消息写入流程" class="headerlink" title="4. 消息写入流程"></a>4. 消息写入流程</h2><ol>
<li><p><strong>消息打包</strong>：Producer 发送的消息经过序列化形成消息体</p>
</li>
<li><p><strong>异步刷盘 &#x2F; 同步刷盘</strong>：</p>
<ul>
<li><p><strong>异步刷盘（默认）</strong>：消息先写入操作系统页缓存，后台线程定时刷盘到磁盘，提高吞吐</p>
</li>
<li><p><strong>同步刷盘</strong>：等待消息写入磁盘确认，确保消息安全，性能较低</p>
</li>
</ul>
</li>
<li><p><strong>追加到 CommitLog</strong>：</p>
<ul>
<li>通过 <code>MappedFileQueue.appendMessage()</code> 顺序写入</li>
</ul>
</li>
<li><p><strong>返回消息存储结果</strong>，包括物理偏移量</p>
</li>
</ol>
<hr>
<h2 id="5-ConsumeQueue-索引机制"><a href="#5-ConsumeQueue-索引机制" class="headerlink" title="5. ConsumeQueue 索引机制"></a>5. ConsumeQueue 索引机制</h2><ul>
<li><p>每个 Topic-Queue 对应一个 ConsumeQueue 文件，记录消息在 CommitLog 的物理偏移量</p>
</li>
<li><p>ConsumeQueue 以固定长度的条目存储，便于快速定位消息</p>
</li>
<li><p>Consumer 通过 ConsumeQueue 读取消息偏移，快速从 CommitLog 拉取消息</p>
</li>
</ul>
<hr>
<h2 id="6-消息刷盘策略"><a href="#6-消息刷盘策略" class="headerlink" title="6. 消息刷盘策略"></a>6. 消息刷盘策略</h2><table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
<th>优缺点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>异步刷盘</strong></td>
<td>写入操作系统缓存，定时刷盘到磁盘</td>
<td>高吞吐，可能丢少量数据</td>
</tr>
<tr>
<td><strong>同步刷盘</strong></td>
<td>等待刷盘确认后返回</td>
<td>高可靠，吞吐低</td>
</tr>
</tbody></table>
<p>刷盘策略可配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">flushDiskType</span> = <span class="hljs-string">ASYNC_FLUSH   # 或 SYNC_FLUSH</span><br></code></pre></td></tr></table></figure>

<hr>
<h2 id="7-高可用复制（Broker-主从复制）"><a href="#7-高可用复制（Broker-主从复制）" class="headerlink" title="7. 高可用复制（Broker 主从复制）"></a>7. 高可用复制（Broker 主从复制）</h2><ul>
<li><p><strong>Master + Slave 架构</strong></p>
</li>
<li><p>Slave 同步 Master 的 CommitLog 数据</p>
</li>
<li><p>支持同步复制和异步复制两种模式</p>
</li>
<li><p>提高数据安全性和容灾能力</p>
</li>
</ul>
<hr>
<h2 id="8-清理策略"><a href="#8-清理策略" class="headerlink" title="8. 清理策略"></a>8. 清理策略</h2><ul>
<li><p>根据磁盘使用率和时间阈值自动删除过期 CommitLog 文件</p>
</li>
<li><p>配合消息消费状态，确保不删除未消费消息</p>
</li>
</ul>
<hr>
<h2 id="📝-存储结构简图"><a href="#📝-存储结构简图" class="headerlink" title="📝 存储结构简图"></a>📝 存储结构简图</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">+---------------------------+<br>|         CommitLog         |  顺序存储消息数据（消息体、元数据）<br>+---------------------------+<br>           ↑<br>           | 物理偏移<br>+---------------------------+<br>|       ConsumeQueue        |  消息消费索引，快速定位消息偏移<br>+---------------------------+<br>           ↑<br>           |<br>+---------------------------+<br>|        IndexFile          |  根据 Key 快速查找消息<br>+---------------------------+<br></code></pre></td></tr></table></figure>
<h1 id="RocketMQ-CommitLog写入过程解读"><a href="#RocketMQ-CommitLog写入过程解读" class="headerlink" title="RocketMQ CommitLog写入过程解读"></a><strong>RocketMQ CommitLog写入过程解读</strong></h1><hr>
<h2 id="1-写入入口"><a href="#1-写入入口" class="headerlink" title="1. 写入入口"></a>1. 写入入口</h2><p>当 Broker 收到发送请求时，最终调用的写入接口是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> AppendMessageResult <span class="hljs-title function_">appendMessage</span><span class="hljs-params">(MessageExtBrokerInner msg)</span><br></code></pre></td></tr></table></figure>

<p>此方法位于 <code>CommitLog</code> 类中，负责将消息追加写入到 CommitLog 文件。</p>
<hr>
<h2 id="2-文件选择"><a href="#2-文件选择" class="headerlink" title="2. 文件选择"></a>2. 文件选择</h2><ul>
<li><p>RocketMQ 将 CommitLog 分成多个固定大小文件（默认 1GB）</p>
</li>
<li><p>根据当前写指针（<code>wrotePosition</code>），找到当前可写的 <code>MappedFile</code></p>
</li>
<li><p>如果当前文件空间不足，会切换到下一个文件</p>
</li>
</ul>
<hr>
<h2 id="3-消息序列化"><a href="#3-消息序列化" class="headerlink" title="3. 消息序列化"></a>3. 消息序列化</h2><p>消息会被序列化成字节数组，结构包含：</p>
<table>
<thead>
<tr>
<th>部分</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>总长度</td>
<td>消息总字节数</td>
</tr>
<tr>
<td>魔数</td>
<td>用于校验数据正确性</td>
</tr>
<tr>
<td>物理偏移量</td>
<td>当前消息在文件中的偏移量</td>
</tr>
<tr>
<td>消息体</td>
<td>主题、消息体、属性等内容</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-顺序写入（MappedFile）"><a href="#4-顺序写入（MappedFile）" class="headerlink" title="4. 顺序写入（MappedFile）"></a>4. 顺序写入（MappedFile）</h2><p>RocketMQ 使用了 <strong>内存映射文件</strong> (<code>MappedByteBuffer</code>)，写入时直接操作映射到内存的字节缓冲区，写操作是顺序追加：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mappedByteBuffer.put(messageBytes);<br></code></pre></td></tr></table></figure>

<p>写操作在内存完成，底层操作系统负责异步刷新到磁盘。</p>
<hr>
<h2 id="5-追加写入结果"><a href="#5-追加写入结果" class="headerlink" title="5. 追加写入结果"></a>5. 追加写入结果</h2><p>写入成功后，<code>appendMessage()</code> 返回 <code>AppendMessageResult</code>，包含：</p>
<ul>
<li><p>写入的物理偏移量（CommitLog 文件中的偏移）</p>
</li>
<li><p>消息ID（通常是偏移量和主机信息组合）</p>
</li>
<li><p>状态码（成功或失败原因）</p>
</li>
</ul>
<hr>
<h2 id="6-刷盘机制（Flush）"><a href="#6-刷盘机制（Flush）" class="headerlink" title="6. 刷盘机制（Flush）"></a>6. 刷盘机制（Flush）</h2><p>消息写入 CommitLog 只是写入内存映射缓存，刷盘分为两种：</p>
<table>
<thead>
<tr>
<th>刷盘类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>异步刷盘</td>
<td>后台刷盘线程定时将数据写入磁盘</td>
</tr>
<tr>
<td>同步刷盘</td>
<td>等待刷盘操作完成，确保数据落盘</td>
</tr>
</tbody></table>
<p>刷盘动作由 <code>flush()</code> 方法触发，刷盘完成后才能确认消息持久化成功。</p>
<hr>
<h2 id="7-消息索引构建"><a href="#7-消息索引构建" class="headerlink" title="7. 消息索引构建"></a>7. 消息索引构建</h2><p>写完 CommitLog 后，Broker 会更新：</p>
<ul>
<li><p><strong>ConsumeQueue</strong>（消费队列索引）</p>
</li>
<li><p><strong>IndexFile</strong>（消息键索引）</p>
</li>
</ul>
<p>便于快速查找和消费。</p>
<hr>
<h2 id="📝-CommitLog-写入流程示意图"><a href="#📝-CommitLog-写入流程示意图" class="headerlink" title="📝 CommitLog 写入流程示意图"></a>📝 CommitLog 写入流程示意图</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">[Broker接收消息]<br>        ↓<br>[调用 CommitLog.appendMessage()]<br>        ↓<br>[选择当前 MappedFile]<br>        ↓<br>[序列化消息成字节]<br>        ↓<br>[顺序写入 MappedByteBuffer]<br>        ↓<br>[返回写入结果 AppendMessageResult]<br>        ↓<br>[刷盘（异步或同步）]<br>        ↓<br>[更新 ConsumeQueue 和索引文件]<br></code></pre></td></tr></table></figure>
<h1 id="RocketMQ-索引文件管理过程解读"><a href="#RocketMQ-索引文件管理过程解读" class="headerlink" title="RocketMQ 索引文件管理过程解读"></a><strong>RocketMQ 索引文件管理过程解读</strong></h1><hr>
<h2 id="🔍-什么是-IndexFile？"><a href="#🔍-什么是-IndexFile？" class="headerlink" title="🔍 什么是 IndexFile？"></a>🔍 什么是 IndexFile？</h2><p><code>IndexFile</code> 是 RocketMQ 的消息索引文件，默认用于 <strong>按 Key（即 Message Key 或 Unique Key）快速定位消息在 CommitLog 中的物理偏移量</strong>。</p>
<ul>
<li><p>每个 <code>IndexFile</code> 文件默认可以记录约 <strong>2000 万条索引</strong></p>
</li>
<li><p>每天会生成多个文件，类似时间窗口滚动日志</p>
</li>
<li><p><strong>不是必须组件</strong>，只在开启了 key 索引的消息使用（<code>msg.setKeys(...)</code>）</p>
</li>
</ul>
<hr>
<h2 id="📁-索引文件结构"><a href="#📁-索引文件结构" class="headerlink" title="📁 索引文件结构"></a>📁 索引文件结构</h2><p>一个 IndexFile 包含 3 个部分：</p>
<table>
<thead>
<tr>
<th>区域名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Index Header</td>
<td>文件元信息：开始&#x2F;结束时间戳、偏移等</td>
</tr>
<tr>
<td>Hash Slot 区域</td>
<td>500万个 Slot，每个4字节（int），保存链表头</td>
</tr>
<tr>
<td>Index Entry 区域</td>
<td>每个 Entry 20字节，保存实际的索引记录</td>
</tr>
</tbody></table>
<h3 id="每个索引项结构如下（共20字节）："><a href="#每个索引项结构如下（共20字节）：" class="headerlink" title="每个索引项结构如下（共20字节）："></a>每个索引项结构如下（共20字节）：</h3><table>
<thead>
<tr>
<th>字节数</th>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>8</td>
<td>commitLogOffset</td>
<td>消息在 CommitLog 中的偏移量</td>
</tr>
<tr>
<td>4</td>
<td>keyHash</td>
<td>Key 的 Hash 值</td>
</tr>
<tr>
<td>4</td>
<td>timeDiff</td>
<td>相对于文件开始时间的秒差值</td>
</tr>
<tr>
<td>4</td>
<td>prevIndexOffset</td>
<td>上一个索引项的位置（构建链表）</td>
</tr>
</tbody></table>
<hr>
<h2 id="🧬-索引构建过程"><a href="#🧬-索引构建过程" class="headerlink" title="🧬 索引构建过程"></a>🧬 索引构建过程</h2><p>写入消息到 CommitLog 后，如果消息设置了 <code>key</code>，则 RocketMQ 会构建索引：</p>
<ol>
<li><p><strong>计算 key 的 hashCode</strong></p>
</li>
<li><p><strong>定位 Hash Slot</strong>：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">slotPos = keyHash % hashSlotNum<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>获取当前 slot 指向的最新索引项位置（prevIndexOffset）</strong></p>
</li>
<li><p><strong>创建新的 IndexEntry，写入当前 commitLogOffset、timeDiff、keyHash、prevIndexOffset</strong></p>
</li>
<li><p><strong>更新 Hash Slot 的指针为当前 Entry 的索引</strong></p>
</li>
</ol>
<p>就这样，通过 <strong>slot + 单链表</strong> 实现 <strong>多 key 哈希冲突下的链式索引</strong>。</p>
<hr>
<h2 id="🔎-查询消息流程（通过-key）"><a href="#🔎-查询消息流程（通过-key）" class="headerlink" title="🔎 查询消息流程（通过 key）"></a>🔎 查询消息流程（通过 key）</h2><p>调用 <code>MessageStore.lookMessageByKey(...)</code>：</p>
<ol>
<li><p>根据 key 计算 hash 值</p>
</li>
<li><p>定位 slot</p>
</li>
<li><p>遍历该 slot 对应的链表（按 <code>prevIndexOffset</code>）</p>
</li>
<li><p>找到满足时间范围的消息偏移量（commitLogOffset）</p>
</li>
<li><p>从 CommitLog 中读取实际消息并返回</p>
</li>
</ol>
<p><strong>注意</strong>：只能查找最近 7 天内的消息（默认 Index 文件保留时长为 7 天）</p>
<hr>
<h2 id="⏳-索引文件生命周期管理"><a href="#⏳-索引文件生命周期管理" class="headerlink" title="⏳ 索引文件生命周期管理"></a>⏳ 索引文件生命周期管理</h2><ul>
<li><p>每次 Broker 启动时会加载本地 index 目录中的 IndexFile</p>
</li>
<li><p>每个文件最多存放 2000 万条索引，存满后自动创建新文件</p>
</li>
<li><p>每个文件命名为创建时间戳（<code>index-YYYYMMDDHHMMSS</code>）</p>
</li>
<li><p>定期清理过期 IndexFile（配合消息生命周期）</p>
</li>
</ul>
<hr>
<h2 id="🚦-实际使用注意事项"><a href="#🚦-实际使用注意事项" class="headerlink" title="🚦 实际使用注意事项"></a>🚦 实际使用注意事项</h2><table>
<thead>
<tr>
<th>项目</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td>是否开启消息 key</td>
<td>仅对需要按 key 查询的消息设置 key</td>
</tr>
<tr>
<td>查询性能影响</td>
<td>仅支持简单 key 索引，不支持复杂 SQL92 查询</td>
</tr>
<tr>
<td>存储空间消耗</td>
<td>key 多会导致 IndexFile 膨胀</td>
</tr>
<tr>
<td>不适合场景</td>
<td>频繁 key 查询、索引保留时间要求很长</td>
</tr>
</tbody></table>
<h1 id="RocketMQ-索引文件中key的解释"><a href="#RocketMQ-索引文件中key的解释" class="headerlink" title="RocketMQ 索引文件中key的解释"></a><strong>RocketMQ 索引文件中key的解释</strong></h1><h2 id="✅-简单定义"><a href="#✅-简单定义" class="headerlink" title="✅ 简单定义"></a>✅ 简单定义</h2><p><strong>Key 是用户为消息指定的业务标识符</strong>，用于 RocketMQ 构建索引（IndexFile），从而支持通过 key 快速查找消息。</p>
<p>你可以把它看作是“消息的业务主键”。</p>
<hr>
<h2 id="📌-设置-Key-的方式"><a href="#📌-设置-Key-的方式" class="headerlink" title="📌 设置 Key 的方式"></a>📌 设置 Key 的方式</h2><p>当你发送消息时，可以通过如下方式设置 key：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;TopicTest&quot;</span>, <span class="hljs-string">&quot;TagA&quot;</span>, <span class="hljs-string">&quot;order123456&quot;</span>, msgBody);<br>msg.setKeys(<span class="hljs-string">&quot;order123456&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>这个 <code>&quot;order123456&quot;</code> 就是 key，可以是：</p>
<ul>
<li><p>订单号</p>
</li>
<li><p>用户ID</p>
</li>
<li><p>业务流水号</p>
</li>
<li><p>任何你想日后追踪&#x2F;查询的业务标识</p>
</li>
</ul>
<hr>
<h2 id="🧠-key-的作用"><a href="#🧠-key-的作用" class="headerlink" title="🧠 key 的作用"></a>🧠 key 的作用</h2><table>
<thead>
<tr>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>🔍 消息追踪</td>
<td>运维&#x2F;业务可通过 key 查询消息轨迹（查询、消费状态）</td>
</tr>
<tr>
<td>🧾 日志审计</td>
<td>跟踪某一笔交易&#x2F;事件消息在系统中流转情况</td>
</tr>
<tr>
<td>🔗 构建索引（IndexFile）</td>
<td>RocketMQ 会自动为设置了 key 的消息生成索引文件</td>
</tr>
<tr>
<td>🚨 故障恢复</td>
<td>某些异常场景下可以通过 key 重新找回消息</td>
</tr>
</tbody></table>
<hr>
<h2 id="🔄-多个-key"><a href="#🔄-多个-key" class="headerlink" title="🔄 多个 key"></a>🔄 多个 key</h2><p>你可以设置多个 key，用空格隔开：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">msg.setKeys(<span class="hljs-string">&quot;order123 user456 session789&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>RocketMQ 会为每个 key 单独创建一条索引记录。</p>
<hr>
<h2 id="⚠️-注意事项"><a href="#⚠️-注意事项" class="headerlink" title="⚠️ 注意事项"></a>⚠️ 注意事项</h2><table>
<thead>
<tr>
<th>项目</th>
<th>建议&#x2F;说明</th>
</tr>
</thead>
<tbody><tr>
<td>key 不是消息 ID</td>
<td>key 是用户业务设置的标识，msgId 是系统生成的全局唯一ID</td>
</tr>
<tr>
<td>key 长度限制</td>
<td>建议不要太长，否则会增加索引文件大小</td>
</tr>
<tr>
<td>key 不保证唯一</td>
<td>如果你设置了重复的 key，索引会追加，不覆盖</td>
</tr>
<tr>
<td>key 查询有效期</td>
<td>受 IndexFile 的保存时长影响（默认 7 天）</td>
</tr>
</tbody></table>
<hr>
<h2 id="🔧-使用-key-查询消息"><a href="#🔧-使用-key-查询消息" class="headerlink" title="🔧 使用 key 查询消息"></a>🔧 使用 key 查询消息</h2><p>你可以通过管理控制台或 API 查询某个 key 对应的消息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sh mqadmin queryMessage -n localhost:9876 -t TopicTest -k order123456<br></code></pre></td></tr></table></figure>

<p>或通过 Java API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MessageExt</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> consumer.viewMessageByKey(<span class="hljs-string">&quot;TopicTest&quot;</span>, <span class="hljs-string">&quot;order123456&quot;</span>);<br></code></pre></td></tr></table></figure>
      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>单线程垃圾清理工</li>
    <li><strong>本文链接：</strong><a href="https://rongxiaohan.github.io/2024/06/03/RocketMQ%E8%BF%9B%E9%98%B6%E4%B8%89%E4%B9%8B%E7%BB%84%E4%BB%B6%E8%A7%A3%E8%AF%BB/index.html" title="https:&#x2F;&#x2F;rongxiaohan.github.io&#x2F;2024&#x2F;06&#x2F;03&#x2F;RocketMQ%E8%BF%9B%E9%98%B6%E4%B8%89%E4%B9%8B%E7%BB%84%E4%BB%B6%E8%A7%A3%E8%AF%BB&#x2F;index.html">https:&#x2F;&#x2F;rongxiaohan.github.io&#x2F;2024&#x2F;06&#x2F;03&#x2F;RocketMQ%E8%BF%9B%E9%98%B6%E4%B8%89%E4%B9%8B%E7%BB%84%E4%BB%B6%E8%A7%A3%E8%AF%BB&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/RocketMQ/" rel="tag">RocketMQ</a></li></ul> 

        
  <nav class="nav">
    <a href="/2024/06/04/RocketMQ%E8%BF%9B%E9%98%B6%E5%9B%9B/"><i class="iconfont iconleft"></i>RocketMQ进阶四</a>
    <a href="/2024/06/02/RocketMQ%E8%BF%9B%E9%98%B6%E4%BA%8C/">RocketMQ进阶二<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RocketMQ-NameServer%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%A2%B3%E7%90%86"><span class="toc-text">RocketMQ NameServer启动过程梳理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-1-%E5%85%A5%E5%8F%A3%E7%B1%BB-NamesrvStartup-main"><span class="toc-text">🧩 1. 入口类 NamesrvStartup.main()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%A7-2-%E5%88%9B%E5%BB%BA-NamesrvController"><span class="toc-text">🔧 2. 创建 NamesrvController</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-3-NamesrvController-initialize"><span class="toc-text">⚙️ 3. NamesrvController.initialize()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8F%81-4-NamesrvController-start"><span class="toc-text">🏁 4. NamesrvController.start()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%84-%E5%90%8E%E5%8F%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-text">🔄 后台定时任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%AA%9C-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93%E5%9B%BE"><span class="toc-text">🪜 启动流程总结图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%A1-%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82%E8%A1%A5%E5%85%85"><span class="toc-text">💡 一些细节补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-text">1. 路由信息的管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Broker-%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86"><span class="toc-text">2. Broker 注册原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93"><span class="toc-text">✅ 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RocketMQ-Broker%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%A2%B3%E7%90%86"><span class="toc-text">RocketMQ Broker启动过程梳理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%80-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%80%BB%E8%A7%88"><span class="toc-text">🚀 启动流程总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-1-BrokerStartup-main"><span class="toc-text">🧩 1. BrokerStartup.main()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-2-createBrokerController-args"><span class="toc-text">⚙️ 2. createBrokerController(args)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%A7-3-BrokerController-initialize"><span class="toc-text">🔧 3. BrokerController.initialize()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8F%81-4-BrokerController-start"><span class="toc-text">🏁 4. BrokerController.start()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%81-%E6%B3%A8%E5%86%8C%E5%88%B0-NameServer"><span class="toc-text">🔁 注册到 NameServer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">注册做了什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%BE-%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E7%BB%84%E4%BB%B6-DefaultMessageStore"><span class="toc-text">💾 消息存储组件 DefaultMessageStore</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%80%BB%E7%BB%93"><span class="toc-text">🧠 启动流程图总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RocketMQ-Netty%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%A1%86%E6%9E%B6"><span class="toc-text">RocketMQ Netty服务注册框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%80-1-RocketMQ-%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%A1%86%E6%9E%B6%E7%BB%84%E6%88%90"><span class="toc-text">🚀 1. RocketMQ 的服务注册框架组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-2-NameServer-%E7%9A%84%E6%B3%A8%E5%86%8C%E6%9C%BA%E5%88%B6%EF%BC%88%E8%87%AA%E7%A0%94%EF%BC%89"><span class="toc-text">🧩 2. NameServer 的注册机制（自研）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-3-Broker-%E6%B3%A8%E5%86%8C-NameServer-%E6%B5%81%E7%A8%8B%EF%BC%88%E5%9F%BA%E4%BA%8E-Netty%EF%BC%89"><span class="toc-text">🧠 3. Broker 注册 NameServer 流程（基于 Netty）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Broker-%E5%90%AF%E5%8A%A8%E6%97%B6%E4%BC%9A%E5%AE%9A%E6%97%B6%E6%B3%A8%E5%86%8C%EF%BC%9A"><span class="toc-text">Broker 启动时会定时注册：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E6%96%B9%E6%B3%95%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-text">注册方法核心逻辑：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%A7-4-Netty-%E5%9C%A8-RocketMQ-%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">🔧 4. Netty 在 RocketMQ 中的使用方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%89%EF%B8%8F-5-%E6%B3%A8%E5%86%8C%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%88REGISTER-BROKER%EF%BC%89"><span class="toc-text">✉️ 5. 注册请求协议（REGISTER_BROKER）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%97%82%EF%B8%8F-6-NameServer-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%88%E6%B3%A8%E5%86%8C%E7%BB%93%E6%9E%9C%E7%9A%84%E8%90%BD%E5%9C%B0%EF%BC%89"><span class="toc-text">🗂️ 6. NameServer 内存结构（注册结果的落地）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%AF-%E5%B0%8F%E7%BB%93%EF%BC%9ARocketMQ-%E8%87%AA%E7%A0%94%E7%9A%84-Netty-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%A1%86%E6%9E%B6"><span class="toc-text">🎯 小结：RocketMQ 自研的 Netty 服务注册框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RocketMQ-Broker%E5%BF%83%E8%B7%B3%E6%B3%A8%E5%86%8C%E7%AE%A1%E7%90%86"><span class="toc-text">RocketMQ Broker心跳注册管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%AF-%E7%9B%AE%E6%A0%87%EF%BC%9ABroker-%E5%92%8C-NameServer-%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E2%80%9C%E5%9C%A8%E7%BA%BF%E6%84%9F%E7%9F%A5%E2%80%9D"><span class="toc-text">🎯 目标：Broker 和 NameServer 如何保持“在线感知”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E4%B8%80%E3%80%81Broker-%E5%AE%9A%E6%97%B6%E6%B3%A8%E5%86%8C%E6%9C%BA%E5%88%B6%EF%BC%88%E5%BF%83%E8%B7%B3%E5%BC%8F%E6%B3%A8%E5%86%8C%EF%BC%89"><span class="toc-text">🧩 一、Broker 定时注册机制（心跳式注册）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%BB%BB%E5%8A%A1%E5%9C%A8-Broker-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E8%AE%BE%E7%BD%AE%EF%BC%9A"><span class="toc-text">注册任务在 Broker 初始化时设置：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%8F-30-%E7%A7%92-%E5%90%91%E6%89%80%E6%9C%89-NameServer-%E5%8F%91%E9%80%81-REGISTER-BROKER-%E8%AF%B7%E6%B1%82"><span class="toc-text">每 30 秒 向所有 NameServer 发送 REGISTER_BROKER 请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%BA%8C%E3%80%81NameServer-%E5%A4%84%E7%90%86%E6%B3%A8%E5%86%8C%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">🧠 二、NameServer 处理注册的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%81-%E4%B8%89%E3%80%81%E5%BF%83%E8%B7%B3%E8%B6%85%E6%97%B6%E6%A3%80%E6%9F%A5%EF%BC%88NameServer-%E6%B8%85%E7%90%86%E6%AD%BB%E6%8E%89%E7%9A%84-Broker%EF%BC%89"><span class="toc-text">🔁 三、心跳超时检查（NameServer 清理死掉的 Broker）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%EF%BC%9A"><span class="toc-text">默认过期时间：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%97%82%EF%B8%8F-%E5%9B%9B%E3%80%81%E6%A0%B8%E5%BF%83%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%88RouteInfoManager%EF%BC%89"><span class="toc-text">🗂️ 四、核心内存结构（RouteInfoManager）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AA-%E4%BA%94%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B7%AF%E7%94%B1%E6%9F%A5%E8%AF%A2%E4%B8%8E%E5%AE%B9%E7%81%BE"><span class="toc-text">🧪 五、客户端路由查询与容灾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%9A"><span class="toc-text">✅ 总结一句话：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8C-%E8%A1%A5%E5%85%85%EF%BC%9A%E4%B8%BB%E4%BB%8E-Broker-%E7%9A%84%E6%B3%A8%E5%86%8C%E5%B7%AE%E5%BC%82"><span class="toc-text">📌 补充：主从 Broker 的注册差异</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RocketMQ-Producer%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E8%BF%87%E7%A8%8B%E8%A7%A3%E8%AF%BB"><span class="toc-text">RocketMQ Producer发送消息过程解读</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Producer-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%85%A5%E5%8F%A3"><span class="toc-text">1. Producer 发送消息的入口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1%E8%8E%B7%E5%8F%96%EF%BC%88%E5%90%91-NameServer-%E6%8B%89%E5%8F%96-Topic-%E8%B7%AF%E7%94%B1%EF%BC%89"><span class="toc-text">2. 路由获取（向 NameServer 拉取 Topic 路由）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%80%89%E6%8B%A9%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%89"><span class="toc-text">3. 选择消息队列（负载均衡）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%EF%BC%88%E8%B0%83%E7%94%A8%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%EF%BC%89"><span class="toc-text">4. 发送消息（调用网络通信）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%8F%91%E9%80%81%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8"><span class="toc-text">4.1 发送接口调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E6%9E%84%E9%80%A0%EF%BC%88RemotingCommand%EF%BC%89"><span class="toc-text">4.2 发送请求构造（RemotingCommand）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E9%80%9A%E8%BF%87-Netty-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-text">4.3 通过 Netty 发送消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Broker-%E6%8E%A5%E6%94%B6%E5%B9%B6%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF"><span class="toc-text">5. Broker 接收并处理消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Producer-%E6%8E%A5%E6%94%B6%E5%93%8D%E5%BA%94"><span class="toc-text">6. Producer 接收响应</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E5%92%8C%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-text">7. 失败重试和事务消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%9D-%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93%E5%9B%BE"><span class="toc-text">📝 流程总结图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RocketMQ-Consumer%E6%8B%89%E5%8F%96%E6%B6%88%E6%81%AF%E8%BF%87%E7%A8%8B%E8%A7%A3%E8%AF%BB"><span class="toc-text">RocketMQ Consumer拉取消息过程解读</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Consumer-%E5%90%AF%E5%8A%A8%E8%AE%A2%E9%98%85%E6%B5%81%E7%A8%8B"><span class="toc-text">1. Consumer 启动订阅流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8B%89%E5%8F%96%E6%B6%88%E6%81%AF%E8%A7%A6%E5%8F%91%E7%82%B9"><span class="toc-text">2. 拉取消息触发点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96-Topic-%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF"><span class="toc-text">3. 获取 Topic 路由信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%8B%89%E5%8F%96%E6%B6%88%E6%81%AF%E8%AF%B7%E6%B1%82%E6%9E%84%E9%80%A0"><span class="toc-text">4. 拉取消息请求构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%8F%91%E9%80%81%E6%8B%89%E5%8F%96%E8%AF%B7%E6%B1%82%EF%BC%88Netty-%E9%80%9A%E4%BF%A1%EF%BC%89"><span class="toc-text">5. 发送拉取请求（Netty 通信）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Broker-%E5%A4%84%E7%90%86%E6%8B%89%E5%8F%96%E8%AF%B7%E6%B1%82"><span class="toc-text">6. Broker 处理拉取请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Consumer-%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="toc-text">7. Consumer 接收消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%B6%88%E8%B4%B9%E8%BF%9B%E5%BA%A6%E6%8F%90%E4%BA%A4%EF%BC%88offset-%E7%AE%A1%E7%90%86%EF%BC%89"><span class="toc-text">8. 消费进度提交（offset 管理）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95%E5%92%8C%E5%A4%B1%E8%B4%A5%E5%A4%84%E7%90%86"><span class="toc-text">9. 消息重试和失败处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%9D-%E6%8B%89%E5%8F%96%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B%E7%AE%80%E5%8C%96%E5%9B%BE"><span class="toc-text">📝 拉取消息流程简化图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RocketMQ-%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D"><span class="toc-text">RocketMQ 消息持久化机制介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-RocketMQ-%E6%8C%81%E4%B9%85%E5%8C%96%E6%A6%82%E8%BF%B0"><span class="toc-text">1. RocketMQ 持久化概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E5%AD%98%E5%82%A8%E7%BB%84%E4%BB%B6"><span class="toc-text">2. 核心存储组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-CommitLog-%E8%AF%A6%E8%A7%A3"><span class="toc-text">3. CommitLog 详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%B6%88%E6%81%AF%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="toc-text">4. 消息写入流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-ConsumeQueue-%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6"><span class="toc-text">5. ConsumeQueue 索引机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%B6%88%E6%81%AF%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5"><span class="toc-text">6. 消息刷盘策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%AB%98%E5%8F%AF%E7%94%A8%E5%A4%8D%E5%88%B6%EF%BC%88Broker-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%89"><span class="toc-text">7. 高可用复制（Broker 主从复制）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%B8%85%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-text">8. 清理策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%9D-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%AE%80%E5%9B%BE"><span class="toc-text">📝 存储结构简图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RocketMQ-CommitLog%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B%E8%A7%A3%E8%AF%BB"><span class="toc-text">RocketMQ CommitLog写入过程解读</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%86%99%E5%85%A5%E5%85%A5%E5%8F%A3"><span class="toc-text">1. 写入入口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%96%87%E4%BB%B6%E9%80%89%E6%8B%A9"><span class="toc-text">2. 文件选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B6%88%E6%81%AF%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">3. 消息序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%A1%BA%E5%BA%8F%E5%86%99%E5%85%A5%EF%BC%88MappedFile%EF%BC%89"><span class="toc-text">4. 顺序写入（MappedFile）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%BF%BD%E5%8A%A0%E5%86%99%E5%85%A5%E7%BB%93%E6%9E%9C"><span class="toc-text">5. 追加写入结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%88%B7%E7%9B%98%E6%9C%BA%E5%88%B6%EF%BC%88Flush%EF%BC%89"><span class="toc-text">6. 刷盘机制（Flush）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%B6%88%E6%81%AF%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA"><span class="toc-text">7. 消息索引构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%9D-CommitLog-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-text">📝 CommitLog 写入流程示意图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RocketMQ-%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E8%BF%87%E7%A8%8B%E8%A7%A3%E8%AF%BB"><span class="toc-text">RocketMQ 索引文件管理过程解读</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E4%BB%80%E4%B9%88%E6%98%AF-IndexFile%EF%BC%9F"><span class="toc-text">🔍 什么是 IndexFile？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%81-%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">📁 索引文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%8F%E4%B8%AA%E7%B4%A2%E5%BC%95%E9%A1%B9%E7%BB%93%E6%9E%84%E5%A6%82%E4%B8%8B%EF%BC%88%E5%85%B120%E5%AD%97%E8%8A%82%EF%BC%89%EF%BC%9A"><span class="toc-text">每个索引项结构如下（共20字节）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AC-%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-text">🧬 索引构建过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8E-%E6%9F%A5%E8%AF%A2%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B%EF%BC%88%E9%80%9A%E8%BF%87-key%EF%BC%89"><span class="toc-text">🔎 查询消息流程（通过 key）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%8F%B3-%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="toc-text">⏳ 索引文件生命周期管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%A6-%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">🚦 实际使用注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RocketMQ-%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E4%B8%ADkey%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="toc-text">RocketMQ 索引文件中key的解释</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E7%AE%80%E5%8D%95%E5%AE%9A%E4%B9%89"><span class="toc-text">✅ 简单定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8C-%E8%AE%BE%E7%BD%AE-Key-%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">📌 设置 Key 的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-key-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">🧠 key 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%84-%E5%A4%9A%E4%B8%AA-key"><span class="toc-text">🔄 多个 key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">⚠️ 注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%A7-%E4%BD%BF%E7%94%A8-key-%E6%9F%A5%E8%AF%A2%E6%B6%88%E6%81%AF"><span class="toc-text">🔧 使用 key 查询消息</span></a></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=894519210 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconwechat-fill "></i>
      </a><a 
        href="https://www.instagram.com/izhaoo/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconinstagram "></i>
      </a><a 
        href="https://github.com/zhaoo "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:izhaoo@163.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p></p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
    <div class="scrollbar j-scrollbar">
  <div class="scrollbar-current j-scrollbar-current"></div>
</div>
  
  
    
<script src="/js/color-mode.js"></script>

  
  
</body>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>





  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>












</html>