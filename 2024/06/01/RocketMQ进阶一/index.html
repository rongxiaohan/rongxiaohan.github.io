

<!DOCTYPE html>
<html lang="zh-Hans" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>RocketMQ进阶一 - 笑容+</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  <meta name="keywords" content="技术博客, Java, Python, Node.js, Web 开发">
  <meta name="description" content="
RocketMQ客户端消息确认机制一、两种消费模式1...">
  <meta name="author" content="单线程垃圾清理工">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="https://at.alicdn.com/t/font_1445822_p6ry5n7lrr.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      loading: {
        gif: '/images/theme/loading.gif',
        lottie: ''
      },
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: {
          gif: '/images/theme/loading.gif',
          lottie: ''
        }
      },
      donate: {
        enable: false,
        alipay: 'https://pic.izhaoo.com/alipay.jpg',
        wechat: 'https://pic.izhaoo.com/wechat.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'simple'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: false,
        path: ''
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 7.3.0"></head>

<body class="lock-screen">
  <div class="loading" id="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
    </div>
    <div class="center">RocketMQ进阶一</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries/ " class="underline "> 生活</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/theme/post-image.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">RocketMQ进阶一</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>June 01, 2024</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>6855</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        
        <hr>
<h1 id="RocketMQ客户端消息确认机制"><a href="#RocketMQ客户端消息确认机制" class="headerlink" title="RocketMQ客户端消息确认机制"></a><strong>RocketMQ客户端消息确认机制</strong></h1><h2 id="一、两种消费模式"><a href="#一、两种消费模式" class="headerlink" title="一、两种消费模式"></a>一、两种消费模式</h2><h3 id="1-集群模式（Clustering）"><a href="#1-集群模式（Clustering）" class="headerlink" title="1. 集群模式（Clustering）"></a>1. <strong>集群模式（Clustering）</strong></h3><ul>
<li><p>多个消费者组成一个消费者组，<strong>每条消息只会被其中一个消费者处理</strong>。</p>
</li>
<li><p>适合负载均衡。</p>
</li>
</ul>
<h3 id="2-广播模式（Broadcasting）"><a href="#2-广播模式（Broadcasting）" class="headerlink" title="2. 广播模式（Broadcasting）"></a>2. <strong>广播模式（Broadcasting）</strong></h3><ul>
<li><p>每个消费者都会收到所有消息。</p>
</li>
<li><p>适合日志、通知等场景。</p>
</li>
</ul>
<hr>
<h2 id="📨-二、消息确认机制概述"><a href="#📨-二、消息确认机制概述" class="headerlink" title="📨 二、消息确认机制概述"></a>📨 二、消息确认机制概述</h2><h3 id="🚚-对于消息发送端（Producer）"><a href="#🚚-对于消息发送端（Producer）" class="headerlink" title="🚚 对于消息发送端（Producer）"></a>🚚 对于消息发送端（Producer）</h3><ul>
<li><p><strong>发送成功是否确认</strong>：RocketMQ 有三种发送方式：</p>
<ul>
<li><p><strong>同步发送（sync）</strong>：发送后等待 Broker 确认，成功才返回。<strong>强一致性保障</strong>。</p>
</li>
<li><p><strong>异步发送（async）</strong>：回调方式确认是否发送成功。</p>
</li>
<li><p><strong>单向发送（oneway）</strong>：不等待 Broker 回应，无确认机制（适合日志等对可靠性要求不高的场景）。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="📬-对于消息消费端（Consumer）"><a href="#📬-对于消息消费端（Consumer）" class="headerlink" title="📬 对于消息消费端（Consumer）"></a>📬 对于消息消费端（Consumer）</h3><h4 id="✔-消息确认机制取决于消费模式："><a href="#✔-消息确认机制取决于消费模式：" class="headerlink" title="✔ 消息确认机制取决于消费模式："></a>✔ 消息确认机制取决于消费模式：</h4><h3 id="1-Push-模式"><a href="#1-Push-模式" class="headerlink" title="1. Push 模式"></a>1. <strong>Push 模式</strong></h3><ul>
<li><p>消息由客户端后台线程推送到消费逻辑中。</p>
</li>
<li><p>如果<strong>消费方法执行成功</strong>，客户端自动向 Broker 确认消费成功。</p>
</li>
<li><p>如果消费失败，可以通过设置 <strong>重试机制</strong> 或 <strong>死信队列（DLQ）</strong>。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs,</span><br><span class="hljs-params">                                                    ConsumeConcurrentlyContext context)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 处理消息逻辑</span><br>            <span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS; <span class="hljs-comment">// 确认消费成功</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// 消费失败，稍后重试</span><br>            <span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="2-Pull-模式"><a href="#2-Pull-模式" class="headerlink" title="2. Pull 模式"></a>2. <strong>Pull 模式</strong></h3><ul>
<li><p>客户端主动从 Broker 拉取消息，然后手动处理并确认。</p>
</li>
<li><p>需要开发者手动管理消费进度（offset）提交。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">pullConsumer.updateConsumeOffset(messageQueue, pullResult.getNextBeginOffset());<br></code></pre></td></tr></table></figure>

<blockquote>
<p>⚠️ 注意：Pull 模式一般在对消费控制更强的场景使用，如精确控制 offset 的恢复和提交。</p>
</blockquote>
<hr>
<h2 id="🧰-三、消费重试机制"><a href="#🧰-三、消费重试机制" class="headerlink" title="🧰 三、消费重试机制"></a>🧰 三、消费重试机制</h2><ul>
<li><p>默认配置下，RocketMQ 会对消费失败的消息自动重试，默认 <strong>最多重试 16 次</strong>。</p>
</li>
<li><p>超过重试次数后会将消息投递到 <strong>死信队列（DLQ）</strong>。</p>
</li>
</ul>
<hr>
<h2 id="🔐-四、事务消息的确认机制（高级特性）"><a href="#🔐-四、事务消息的确认机制（高级特性）" class="headerlink" title="🔐 四、事务消息的确认机制（高级特性）"></a>🔐 四、事务消息的确认机制（高级特性）</h2><p>事务消息分为三阶段：</p>
<ol>
<li><p><strong>发送 half 消息</strong>（消息暂存，不可见）</p>
</li>
<li><p><strong>执行本地事务</strong></p>
</li>
<li><p><strong>回查并确认提交或回滚消息</strong></p>
</li>
</ol>
<p>Producer 需要实现 <code>TransactionListener</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTransactionListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransactionListener</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> LocalTransactionState <span class="hljs-title function_">executeLocalTransaction</span><span class="hljs-params">(Message msg, Object arg)</span> &#123;<br>        <span class="hljs-comment">// 执行本地事务逻辑</span><br>        <span class="hljs-keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> LocalTransactionState <span class="hljs-title function_">checkLocalTransaction</span><span class="hljs-params">(MessageExt msg)</span> &#123;<br>        <span class="hljs-comment">// Broker 回查时确认事务状态</span><br>        <span class="hljs-keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="📝-总结一下："><a href="#📝-总结一下：" class="headerlink" title="📝 总结一下："></a>📝 总结一下：</h2><table>
<thead>
<tr>
<th>场景</th>
<th>确认机制</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Producer（同步）</td>
<td>Broker 返回成功</td>
<td>最安全</td>
</tr>
<tr>
<td>Producer（异步）</td>
<td>回调函数中处理</td>
<td>成功&#x2F;失败</td>
</tr>
<tr>
<td>Producer（单向）</td>
<td>无确认</td>
<td>不可靠</td>
</tr>
<tr>
<td>Consumer（Push）</td>
<td>返回 <code>CONSUME_SUCCESS</code></td>
<td>自动提交</td>
</tr>
<tr>
<td>Consumer（Pull）</td>
<td>手动提交 offset</td>
<td>更灵活</td>
</tr>
<tr>
<td>消费失败</td>
<td>自动重试 &amp; 死信队列</td>
<td>有最大次数限制</td>
</tr>
<tr>
<td>事务消息</td>
<td>三段式事务确认</td>
<td>高一致性</td>
</tr>
</tbody></table>
<h1 id="RocketMQ广播模式详解"><a href="#RocketMQ广播模式详解" class="headerlink" title="RocketMQ广播模式详解"></a><strong>RocketMQ广播模式详解</strong></h1><hr>
<h2 id="🎙️-什么是-RocketMQ-的广播模式（Broadcasting-Mode）？"><a href="#🎙️-什么是-RocketMQ-的广播模式（Broadcasting-Mode）？" class="headerlink" title="🎙️ 什么是 RocketMQ 的广播模式（Broadcasting Mode）？"></a>🎙️ 什么是 RocketMQ 的广播模式（Broadcasting Mode）？</h2><blockquote>
<p>广播模式指的是：<strong>同一个消费者组内的每一个消费者都会接收到全部的消息副本</strong>。</p>
</blockquote>
<p>通俗点讲，假如你有 3 个消费者实例（A、B、C）都属于一个组，在广播模式下，一条消息会被 <strong>A、B、C 都消费一次</strong>，而不是像集群模式那样只被其中一个消费。</p>
<hr>
<h2 id="一、广播模式的典型应用场景"><a href="#一、广播模式的典型应用场景" class="headerlink" title="一、广播模式的典型应用场景"></a>一、广播模式的典型应用场景</h2><table>
<thead>
<tr>
<th>场景</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>日志收集</td>
<td>每个节点都需要接收并记录同样的信息</td>
</tr>
<tr>
<td>配置下发</td>
<td>服务节点需要同时收到配置变化通知</td>
</tr>
<tr>
<td>多终端推送</td>
<td>发送给多个设备终端（如多个系统模块）</td>
</tr>
<tr>
<td>监控告警</td>
<td>所有监控端都需要感知异常数据</td>
</tr>
</tbody></table>
<hr>
<h2 id="🔧-二、如何使用广播模式（Java-示例）"><a href="#🔧-二、如何使用广播模式（Java-示例）" class="headerlink" title="🔧 二、如何使用广播模式（Java 示例）"></a>🔧 二、如何使用广播模式（Java 示例）</h2><h3 id="1-设置广播模式"><a href="#1-设置广播模式" class="headerlink" title="1. 设置广播模式"></a>1. 设置广播模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-string">&quot;broadcast-group&quot;</span>);<br><br><span class="hljs-comment">// 设置为广播模式</span><br>consumer.setMessageModel(MessageModel.BROADCASTING);<br><br>consumer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br><br>consumer.subscribe(<span class="hljs-string">&quot;BroadcastTopic&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br><br>consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -&gt; &#123;<br>    <span class="hljs-keyword">for</span> (MessageExt msg : msgs) &#123;<br>        System.out.printf(<span class="hljs-string">&quot;广播消息：%s %n&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(msg.getBody()));<br>    &#125;<br>    <span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>&#125;);<br><br>consumer.start();<br></code></pre></td></tr></table></figure>

<p>📝 默认是 <code>MessageModel.CLUSTERING</code>，需要手动设置为 <code>BROADCASTING</code>。</p>
<hr>
<h2 id="🚧-三、广播模式注意事项（踩坑区）"><a href="#🚧-三、广播模式注意事项（踩坑区）" class="headerlink" title="🚧 三、广播模式注意事项（踩坑区）"></a>🚧 三、广播模式注意事项（踩坑区）</h2><h3 id="1-❌-不支持消费重试机制"><a href="#1-❌-不支持消费重试机制" class="headerlink" title="1. ❌ 不支持消费重试机制"></a>1. ❌ 不支持消费重试机制</h3><p>广播模式下，<strong>RocketMQ 不会自动重试消费失败的消息</strong>，因为每个消费者都必须处理一次，所以重试会导致副本错乱。</p>
<blockquote>
<p> 建议在消费逻辑中加入异常捕获机制，自己兜底处理。</p>
</blockquote>
<hr>
<h3 id="2-❌-不支持顺序消费（Broadcast-不保证顺序）"><a href="#2-❌-不支持顺序消费（Broadcast-不保证顺序）" class="headerlink" title="2. ❌ 不支持顺序消费（Broadcast 不保证顺序）"></a>2. ❌ 不支持顺序消费（Broadcast 不保证顺序）</h3><p>由于每个消费者是独立消费的，顺序在广播中就变得没有意义了。</p>
<hr>
<h3 id="3-⚠️-消费进度（offset）是每个消费者独立维护的"><a href="#3-⚠️-消费进度（offset）是每个消费者独立维护的" class="headerlink" title="3. ⚠️ 消费进度（offset）是每个消费者独立维护的"></a>3. ⚠️ 消费进度（offset）是<strong>每个消费者独立维护的</strong></h3><p>在广播模式下，每个消费者都会在 Broker 上维护自己的 offset，因此：</p>
<ul>
<li><p>新加入的消费者不会“抢历史消息”</p>
</li>
<li><p>停止再启动，继续从上次的位置拉取</p>
</li>
</ul>
<h1 id="RocketMQ消息过滤机制"><a href="#RocketMQ消息过滤机制" class="headerlink" title="RocketMQ消息过滤机制"></a><strong>RocketMQ消息过滤机制</strong></h1><hr>
<h2 id="🎯-一、过滤机制分类（两种）"><a href="#🎯-一、过滤机制分类（两种）" class="headerlink" title="🎯 一、过滤机制分类（两种）"></a>🎯 一、过滤机制分类（两种）</h2><p>RocketMQ 支持两种消息过滤方式：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>性能</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>Tag 过滤（标签过滤）</td>
<td>基于 Tag 的简单匹配</td>
<td>高</td>
<td>🚀最快，Broker 做过滤</td>
</tr>
<tr>
<td>SQL 过滤</td>
<td>基于 SQL 表达式的复杂过滤</td>
<td>⚠️中等偏低</td>
<td>灵活强大，需 Broker 开启权限</td>
</tr>
</tbody></table>
<hr>
<h2 id="🏷️-二、Tag-过滤（最常用）"><a href="#🏷️-二、Tag-过滤（最常用）" class="headerlink" title="🏷️ 二、Tag 过滤（最常用）"></a>🏷️ 二、Tag 过滤（最常用）</h2><h3 id="Producer-发送时指定-Tag："><a href="#Producer-发送时指定-Tag：" class="headerlink" title="Producer 发送时指定 Tag："></a>Producer 发送时指定 Tag：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;MyTopic&quot;</span>, <span class="hljs-string">&quot;TagA&quot;</span>, <span class="hljs-string">&quot;Hello TagA&quot;</span>.getBytes());<br>producer.send(msg);<br></code></pre></td></tr></table></figure>

<h3 id="Consumer-订阅时指定过滤规则："><a href="#Consumer-订阅时指定过滤规则：" class="headerlink" title="Consumer 订阅时指定过滤规则："></a>Consumer 订阅时指定过滤规则：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">consumer.subscribe(<span class="hljs-string">&quot;MyTopic&quot;</span>, <span class="hljs-string">&quot;TagA || TagB&quot;</span>); <span class="hljs-comment">// 订阅多个标签</span><br></code></pre></td></tr></table></figure>

<p>📌 注意：</p>
<ul>
<li><p><strong>Tag 过滤只支持逻辑或（||）</strong></p>
</li>
<li><p>单个 Topic 下的 Tag 是逻辑划分，不是物理隔离（比多个 Topic 更轻量）</p>
</li>
</ul>
<hr>
<h2 id="三、SQL-表达式过滤（高级玩法）"><a href="#三、SQL-表达式过滤（高级玩法）" class="headerlink" title="三、SQL 表达式过滤（高级玩法）"></a>三、SQL 表达式过滤（高级玩法）</h2><h3 id="1-启用-SQL-过滤的前提"><a href="#1-启用-SQL-过滤的前提" class="headerlink" title="1. 启用 SQL 过滤的前提"></a>1. 启用 SQL 过滤的前提</h3><p>SQL 过滤是由 Broker 实现的，需要配置文件中开启：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">enablePropertyFilter</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure>

<h3 id="2-Producer-发送带属性的消息："><a href="#2-Producer-发送带属性的消息：" class="headerlink" title="2. Producer 发送带属性的消息："></a>2. Producer 发送带属性的消息：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;MyTopic&quot;</span>, <span class="hljs-string">&quot;Hello SQL Filter&quot;</span>.getBytes());<br>msg.putUserProperty(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>); <span class="hljs-comment">// 添加用户属性</span><br>producer.send(msg);<br></code></pre></td></tr></table></figure>

<h3 id="3-Consumer-使用-SQL-表达式过滤："><a href="#3-Consumer-使用-SQL-表达式过滤：" class="headerlink" title="3. Consumer 使用 SQL 表达式过滤："></a>3. Consumer 使用 SQL 表达式过滤：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">consumer.subscribe(<span class="hljs-string">&quot;MyTopic&quot;</span>, MessageSelector.bySql(<span class="hljs-string">&quot;a BETWEEN 0 AND 10&quot;</span>));<br></code></pre></td></tr></table></figure>

<p>支持的 SQL 表达式语法包括：</p>
<ul>
<li><p>数值比较：<code>&gt;</code>, <code>&lt;</code>, <code>=</code>, <code>BETWEEN</code>, <code>IN</code></p>
</li>
<li><p>字符串比较：<code>LIKE</code></p>
</li>
<li><p>逻辑运算：<code>AND</code>, <code>OR</code>, <code>NOT</code></p>
</li>
</ul>
<p>🔒 <strong>注意安全和性能问题</strong>：</p>
<ul>
<li><p>属性值是字符串（需转换类型）</p>
</li>
<li><p>SQL 过滤不支持复杂计算（比如正则、函数等）</p>
</li>
<li><p><strong>过滤是在 Broker 端完成的，不到消费者就被丢弃</strong> → 节省网络带宽</p>
</li>
</ul>
<hr>
<h2 id="🪤-四、常见陷阱和注意事项"><a href="#🪤-四、常见陷阱和注意事项" class="headerlink" title="🪤 四、常见陷阱和注意事项"></a>🪤 四、常见陷阱和注意事项</h2><table>
<thead>
<tr>
<th>问题</th>
<th>原因</th>
<th>解决方式</th>
</tr>
</thead>
<tbody><tr>
<td>Tag 过滤无效</td>
<td>消费者订阅了 <code>*</code> 或 <code>null</code></td>
<td>明确指定 Tags，如 &#96;TagA</td>
</tr>
<tr>
<td>SQL 过滤报错</td>
<td>Broker 未开启过滤功能</td>
<td><code>enablePropertyFilter=true</code></td>
</tr>
<tr>
<td>属性为 null</td>
<td>没有设置属性或名称拼写错误</td>
<td>检查 <code>putUserProperty()</code> 中的 key 名</td>
</tr>
<tr>
<td>SQL 表达式语法错误</td>
<td>使用了不支持的函数</td>
<td>遵循 RocketMQ SQL92 子集语法</td>
</tr>
</tbody></table>
<hr>
<h2 id="🚀-五、性能对比（谁更快）"><a href="#🚀-五、性能对比（谁更快）" class="headerlink" title="🚀 五、性能对比（谁更快）"></a>🚀 五、性能对比（谁更快）</h2><table>
<thead>
<tr>
<th>类型</th>
<th>过滤端</th>
<th>网络传输</th>
<th>性能</th>
</tr>
</thead>
<tbody><tr>
<td>Tag 过滤</td>
<td>Broker</td>
<td>丢弃无关消息，不占用网络</td>
<td>最快</td>
</tr>
<tr>
<td>SQL 过滤</td>
<td>Broker</td>
<td>同样 Broker 端过滤</td>
<td>⚠️ 次之</td>
</tr>
<tr>
<td>Consumer 端过滤</td>
<td>Client</td>
<td>全量传输后过滤</td>
<td>❌ 性能最差，不推荐</td>
</tr>
</tbody></table>
<hr>
<h2 id="🧪-六、Tag-vs-SQL-Filter-快速对比"><a href="#🧪-六、Tag-vs-SQL-Filter-快速对比" class="headerlink" title="🧪 六、Tag vs SQL Filter 快速对比"></a>🧪 六、Tag vs SQL Filter 快速对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>Tag Filter</th>
<th>SQL Filter</th>
</tr>
</thead>
<tbody><tr>
<td>语法复杂度</td>
<td>简单（”A</td>
<td></td>
</tr>
<tr>
<td>灵活性</td>
<td>一般</td>
<td>非常强（支持属性过滤）</td>
</tr>
<tr>
<td>Broker 支持</td>
<td>默认支持</td>
<td>需开启配置项</td>
</tr>
<tr>
<td>性能</td>
<td>极高</td>
<td>高</td>
</tr>
<tr>
<td>推荐使用场景</td>
<td>大部分业务简单分类</td>
<td>高级路由、策略消息投递等</td>
</tr>
</tbody></table>
<h1 id="RocketMQ顺序消息机制"><a href="#RocketMQ顺序消息机制" class="headerlink" title="RocketMQ顺序消息机制"></a><strong>RocketMQ顺序消息机制</strong></h1><hr>
<h2 id="顺序消息的类型"><a href="#顺序消息的类型" class="headerlink" title="顺序消息的类型"></a>顺序消息的类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>实现难度</th>
</tr>
</thead>
<tbody><tr>
<td>全局顺序消息</td>
<td>所有消息严格顺序</td>
<td>高，需要所有消息进入一个队列</td>
</tr>
<tr>
<td>分区顺序消息</td>
<td>同一业务 Key 的消息顺序</td>
<td>中，多个队列协同</td>
</tr>
</tbody></table>
<p>通常我们实现的是 <strong>分区顺序消息</strong>，既有顺序，又能并发处理其他业务流。</p>
<hr>
<h2 id="🧪-一、顺序消息生产（Producer）"><a href="#🧪-一、顺序消息生产（Producer）" class="headerlink" title="🧪 一、顺序消息生产（Producer）"></a>🧪 一、顺序消息生产（Producer）</h2><p>使用 <code>MessageQueueSelector</code> 把相同业务标识（如 orderId）路由到相同队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> i % <span class="hljs-number">3</span>; <span class="hljs-comment">// 模拟 3 个订单</span><br><br>    <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;OrderTopic&quot;</span>, <span class="hljs-string">&quot;TagA&quot;</span>, (<span class="hljs-string">&quot;Order Step &quot;</span> + i).getBytes());<br><br>    producer.send(msg, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueueSelector</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> MessageQueue <span class="hljs-title function_">select</span><span class="hljs-params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> (Integer) arg;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> id % mqs.size(); <span class="hljs-comment">// 相同 id 分配到同一队列</span><br>            <span class="hljs-keyword">return</span> mqs.get(index);<br>        &#125;<br>    &#125;, orderId);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h3><ul>
<li>orderId 相同的消息 → 落到同一个 MessageQueue → 消费时才能顺序</li>
</ul>
<hr>
<h2 id="📥-二、顺序消息消费（Consumer）"><a href="#📥-二、顺序消息消费（Consumer）" class="headerlink" title="📥 二、顺序消息消费（Consumer）"></a>📥 二、顺序消息消费（Consumer）</h2><h3 id="1-使用-MessageListenerOrderly-注册监听器："><a href="#1-使用-MessageListenerOrderly-注册监听器：" class="headerlink" title="1. 使用 MessageListenerOrderly 注册监听器："></a>1. 使用 <code>MessageListenerOrderly</code> 注册监听器：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerOrderly</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ConsumeOrderlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;<br>        <span class="hljs-keyword">for</span> (MessageExt msg : msgs) &#123;<br>            System.out.printf(<span class="hljs-string">&quot;顺序消费：%s%n&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(msg.getBody()));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ConsumeOrderlyStatus.SUCCESS;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="2-顺序消费特点："><a href="#2-顺序消费特点：" class="headerlink" title="2. 顺序消费特点："></a>2. 顺序消费特点：</h3><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>单线程</td>
<td>每个队列分配一个消费线程</td>
</tr>
<tr>
<td>消费顺序</td>
<td>保证该队列中的消息顺序不乱</td>
</tr>
<tr>
<td>异常重试</td>
<td>消费失败会阻塞该队列的消费，直到成功或跳过</td>
</tr>
</tbody></table>
<hr>
<h2 id="⚠️-三、常见注意事项"><a href="#⚠️-三、常见注意事项" class="headerlink" title="⚠️ 三、常见注意事项"></a>⚠️ 三、常见注意事项</h2><h3 id="1-顺序消费与广播模式不能同时使用-❌"><a href="#1-顺序消费与广播模式不能同时使用-❌" class="headerlink" title="1. 顺序消费与广播模式不能同时使用 ❌"></a>1. 顺序消费与广播模式不能同时使用 ❌</h3><p>广播下每个消费者都会消费消息，<strong>但每个实例间顺序无法保障</strong>。</p>
<h3 id="2-一个队列只能被一个消费者线程消费"><a href="#2-一个队列只能被一个消费者线程消费" class="headerlink" title="2. 一个队列只能被一个消费者线程消费"></a>2. 一个队列只能被一个消费者线程消费</h3><p>否则就没法保证队列内部顺序了。</p>
<h3 id="3-异常重试策略慎用"><a href="#3-异常重试策略慎用" class="headerlink" title="3. 异常重试策略慎用"></a>3. 异常重试策略慎用</h3><p>消费失败会阻塞队列，<strong>若长时间不处理可能导致积压</strong>。</p>
<hr>
<h2 id="📊-四、顺序消息-vs-普通消息对比"><a href="#📊-四、顺序消息-vs-普通消息对比" class="headerlink" title="📊 四、顺序消息 vs 普通消息对比"></a>📊 四、顺序消息 vs 普通消息对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>普通消息</th>
<th>顺序消息</th>
</tr>
</thead>
<tbody><tr>
<td>消息投递</td>
<td>任意队列</td>
<td>特定队列</td>
</tr>
<tr>
<td>消费并发性</td>
<td>高</td>
<td>队列级串行</td>
</tr>
<tr>
<td>消费顺序</td>
<td>不保证</td>
<td>保证单队列顺序</td>
</tr>
<tr>
<td>场景</td>
<td>普通日志、监控</td>
<td>订单、状态流转</td>
</tr>
</tbody></table>
<hr>
<h2 id="🚀-五、顺序消息的业务设计建议"><a href="#🚀-五、顺序消息的业务设计建议" class="headerlink" title="🚀 五、顺序消息的业务设计建议"></a>🚀 五、顺序消息的业务设计建议</h2><table>
<thead>
<tr>
<th>建议</th>
<th>理由</th>
</tr>
</thead>
<tbody><tr>
<td>根据业务 key 做队列路由</td>
<td>如 orderId、userId 保持顺序</td>
</tr>
<tr>
<td>控制队列数量</td>
<td>避免热点 key 导致某个队列拥堵</td>
</tr>
<tr>
<td>消费端实现幂等</td>
<td>防止异常重试导致重复消费</td>
</tr>
<tr>
<td>拆分热点</td>
<td>若部分 key 流量大，可做 hash 拆分</td>
</tr>
</tbody></table>
<hr>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><ul>
<li><p>RocketMQ 顺序消息是“<strong>分区有序</strong>”</p>
</li>
<li><p>保证顺序的关键是“<strong>同一业务 key 路由到同一个队列</strong>”</p>
</li>
<li><p>消费端用 <code>MessageListenerOrderly</code> 保证串行处理</p>
</li>
<li><p>顺序消费适合<strong>流程状态流转类</strong>的业务</p>
</li>
</ul>

      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>单线程垃圾清理工</li>
    <li><strong>本文链接：</strong><a href="https://rongxiaohan.github.io/2024/06/01/RocketMQ%E8%BF%9B%E9%98%B6%E4%B8%80/index.html" title="https:&#x2F;&#x2F;rongxiaohan.github.io&#x2F;2024&#x2F;06&#x2F;01&#x2F;RocketMQ%E8%BF%9B%E9%98%B6%E4%B8%80&#x2F;index.html">https:&#x2F;&#x2F;rongxiaohan.github.io&#x2F;2024&#x2F;06&#x2F;01&#x2F;RocketMQ%E8%BF%9B%E9%98%B6%E4%B8%80&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/RocketMQ/" rel="tag">RocketMQ</a></li></ul> 

        
  <nav class="nav">
    <a href="/2024/06/03/RocketMQ%E8%BF%9B%E9%98%B6%E4%B8%89%E4%B9%8B%E7%BB%84%E4%BB%B6%E8%A7%A3%E8%AF%BB/"><i class="iconfont iconleft"></i>RocketMQ进阶三之组件解读</a>
    <a href="/2024/05/31/RocketMQ%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">RocketMQ快速入门<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RocketMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-text">RocketMQ客户端消息确认机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%A4%E7%A7%8D%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F"><span class="toc-text">一、两种消费模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%EF%BC%88Clustering%EF%BC%89"><span class="toc-text">1. 集群模式（Clustering）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8F%EF%BC%88Broadcasting%EF%BC%89"><span class="toc-text">2. 广播模式（Broadcasting）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%A8-%E4%BA%8C%E3%80%81%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">📨 二、消息确认机制概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9A%9A-%E5%AF%B9%E4%BA%8E%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E7%AB%AF%EF%BC%88Producer%EF%BC%89"><span class="toc-text">🚚 对于消息发送端（Producer）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%AC-%E5%AF%B9%E4%BA%8E%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E7%AB%AF%EF%BC%88Consumer%EF%BC%89"><span class="toc-text">📬 对于消息消费端（Consumer）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Push-%E6%A8%A1%E5%BC%8F"><span class="toc-text">1. Push 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Pull-%E6%A8%A1%E5%BC%8F"><span class="toc-text">2. Pull 模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%B0-%E4%B8%89%E3%80%81%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-text">🧰 三、消费重试机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%90-%E5%9B%9B%E3%80%81%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E7%9A%84%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6%EF%BC%88%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%89"><span class="toc-text">🔐 四、事务消息的确认机制（高级特性）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%9D-%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%EF%BC%9A"><span class="toc-text">📝 总结一下：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RocketMQ%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3"><span class="toc-text">RocketMQ广播模式详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%99%EF%B8%8F-%E4%BB%80%E4%B9%88%E6%98%AF-RocketMQ-%E7%9A%84%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8F%EF%BC%88Broadcasting-Mode%EF%BC%89%EF%BC%9F"><span class="toc-text">🎙️ 什么是 RocketMQ 的广播模式（Broadcasting Mode）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">一、广播模式的典型应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%A7-%E4%BA%8C%E3%80%81%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8F%EF%BC%88Java-%E7%A4%BA%E4%BE%8B%EF%BC%89"><span class="toc-text">🔧 二、如何使用广播模式（Java 示例）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%BE%E7%BD%AE%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8F"><span class="toc-text">1. 设置广播模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%A7-%E4%B8%89%E3%80%81%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8F%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%88%E8%B8%A9%E5%9D%91%E5%8C%BA%EF%BC%89"><span class="toc-text">🚧 三、广播模式注意事项（踩坑区）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E2%9D%8C-%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-text">1. ❌ 不支持消费重试机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E2%9D%8C-%E4%B8%8D%E6%94%AF%E6%8C%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%EF%BC%88Broadcast-%E4%B8%8D%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%EF%BC%89"><span class="toc-text">2. ❌ 不支持顺序消费（Broadcast 不保证顺序）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E2%9A%A0%EF%B8%8F-%E6%B6%88%E8%B4%B9%E8%BF%9B%E5%BA%A6%EF%BC%88offset%EF%BC%89%E6%98%AF%E6%AF%8F%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85%E7%8B%AC%E7%AB%8B%E7%BB%B4%E6%8A%A4%E7%9A%84"><span class="toc-text">3. ⚠️ 消费进度（offset）是每个消费者独立维护的</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RocketMQ%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4%E6%9C%BA%E5%88%B6"><span class="toc-text">RocketMQ消息过滤机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%AF-%E4%B8%80%E3%80%81%E8%BF%87%E6%BB%A4%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%EF%BC%88%E4%B8%A4%E7%A7%8D%EF%BC%89"><span class="toc-text">🎯 一、过滤机制分类（两种）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8F%B7%EF%B8%8F-%E4%BA%8C%E3%80%81Tag-%E8%BF%87%E6%BB%A4%EF%BC%88%E6%9C%80%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-text">🏷️ 二、Tag 过滤（最常用）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Producer-%E5%8F%91%E9%80%81%E6%97%B6%E6%8C%87%E5%AE%9A-Tag%EF%BC%9A"><span class="toc-text">Producer 发送时指定 Tag：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Consumer-%E8%AE%A2%E9%98%85%E6%97%B6%E6%8C%87%E5%AE%9A%E8%BF%87%E6%BB%A4%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-text">Consumer 订阅时指定过滤规则：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81SQL-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%87%E6%BB%A4%EF%BC%88%E9%AB%98%E7%BA%A7%E7%8E%A9%E6%B3%95%EF%BC%89"><span class="toc-text">三、SQL 表达式过滤（高级玩法）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%90%AF%E7%94%A8-SQL-%E8%BF%87%E6%BB%A4%E7%9A%84%E5%89%8D%E6%8F%90"><span class="toc-text">1. 启用 SQL 过滤的前提</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Producer-%E5%8F%91%E9%80%81%E5%B8%A6%E5%B1%9E%E6%80%A7%E7%9A%84%E6%B6%88%E6%81%AF%EF%BC%9A"><span class="toc-text">2. Producer 发送带属性的消息：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Consumer-%E4%BD%BF%E7%94%A8-SQL-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%87%E6%BB%A4%EF%BC%9A"><span class="toc-text">3. Consumer 使用 SQL 表达式过滤：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%AA%A4-%E5%9B%9B%E3%80%81%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">🪤 四、常见陷阱和注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%80-%E4%BA%94%E3%80%81%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%EF%BC%88%E8%B0%81%E6%9B%B4%E5%BF%AB%EF%BC%89"><span class="toc-text">🚀 五、性能对比（谁更快）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AA-%E5%85%AD%E3%80%81Tag-vs-SQL-Filter-%E5%BF%AB%E9%80%9F%E5%AF%B9%E6%AF%94"><span class="toc-text">🧪 六、Tag vs SQL Filter 快速对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RocketMQ%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6"><span class="toc-text">RocketMQ顺序消息机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">顺序消息的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AA-%E4%B8%80%E3%80%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%EF%BC%88Producer%EF%BC%89"><span class="toc-text">🧪 一、顺序消息生产（Producer）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%88%E6%9E%9C%EF%BC%9A"><span class="toc-text">效果：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%A5-%E4%BA%8C%E3%80%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%EF%BC%88Consumer%EF%BC%89"><span class="toc-text">📥 二、顺序消息消费（Consumer）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8-MessageListenerOrderly-%E6%B3%A8%E5%86%8C%E7%9B%91%E5%90%AC%E5%99%A8%EF%BC%9A"><span class="toc-text">1. 使用 MessageListenerOrderly 注册监听器：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">2. 顺序消费特点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E4%B8%89%E3%80%81%E5%B8%B8%E8%A7%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">⚠️ 三、常见注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%E4%B8%8E%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8F%E4%B8%8D%E8%83%BD%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8-%E2%9D%8C"><span class="toc-text">1. 顺序消费与广播模式不能同时使用 ❌</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97%E5%8F%AA%E8%83%BD%E8%A2%AB%E4%B8%80%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85%E7%BA%BF%E7%A8%8B%E6%B6%88%E8%B4%B9"><span class="toc-text">2. 一个队列只能被一个消费者线程消费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BC%82%E5%B8%B8%E9%87%8D%E8%AF%95%E7%AD%96%E7%95%A5%E6%85%8E%E7%94%A8"><span class="toc-text">3. 异常重试策略慎用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8A-%E5%9B%9B%E3%80%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF-vs-%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF%E5%AF%B9%E6%AF%94"><span class="toc-text">📊 四、顺序消息 vs 普通消息对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%80-%E4%BA%94%E3%80%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%BB%BA%E8%AE%AE"><span class="toc-text">🚀 五、顺序消息的业务设计建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B"><span class="toc-text">总结一下</span></a></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"></div>
  
    <div class="footer-copyright"><p></p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
    <div class="scrollbar j-scrollbar">
  <div class="scrollbar-current j-scrollbar-current"></div>
</div>
  
  
    
<script src="/js/color-mode.js"></script>

  
  
</body>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>





  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>












</html>